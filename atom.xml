<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月小水长的个人博客</title>
  
  <subtitle>微信公众号@月小水长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://inspurer.github.io/"/>
  <updated>2023-06-28T02:21:29.716Z</updated>
  <id>https://inspurer.github.io/</id>
  
  <author>
    <name>月小水长</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>站点 bug 维修记录</title>
    <link href="https://inspurer.github.io/2023/06/28/%E7%AB%99%E7%82%B9-bug-%E7%BB%B4%E4%BF%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://inspurer.github.io/2023/06/28/站点-bug-维修记录/</id>
    <published>2023-06-28T01:42:14.000Z</published>
    <updated>2023-06-28T02:21:29.716Z</updated>
    
    <content type="html"><![CDATA[<p>两年多没有更新网站了，这两年，我完成了从一名大厂工程师到连续创业者的转变。<a id="more"></a></p><p>网站由于年久失修，存在了许多 bug，比如部分友链 404，阅读量统计失效等等，由于代码丢失，拖了两年才在旧电脑上找到这份代码，将所有 bug 修好后，发布此篇，以作记录。</p><h3 id="RSA-host-key-for-github-com-has-changed-Could-not-read-from-remote-repository"><a href="#RSA-host-key-for-github-com-has-changed-Could-not-read-from-remote-repository" class="headerlink" title="RSA host key for github.com has changed. Could not read from remote repository"></a>RSA host key for github.com has changed. Could not read from remote repository</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RSA host key for github.com has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\hexoblog\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:182:13)</span><br><span class="line">    at ChildProcess.cp.emit (D:\hexoblog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:961:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:248:5)</span><br></pre></td></tr></table></figure><p>1、如果<code>git config -l</code> 没有输出，在 git 设置一下身份的名字和邮箱，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;your@email.com&quot;</span><br></pre></td></tr></table></figure><p>yourname 必须与 github 的用户名一致</p><p>这里 <a href="mailto:your@email.com" target="_blank" rel="noopener">your@email.com</a> 必须与 github 登录邮箱一致</p><p>2、删除.ssh文件夹下的 known_hosts 文件(该文件主要作用是域名解析)</p><p>3、<code>ssh-keygen -t rsa -C “your@email.com&quot;</code>(填写github对应的邮箱)</p><p>一路回车即可，yes，无需输入</p><p>4、在 github 设置界面新增SSH key 将 id_rsa.pub 里面的内容添加到如图中的 Key 上，Title 可随意。</p><h3 id="Host-key-verification-failed"><a href="#Host-key-verification-failed" class="headerlink" title="Host key verification failed."></a>Host key verification failed.</h3><p> Could not read from remote repository</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\hexoblog\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:182:13)</span><br><span class="line">    at ChildProcess.cp.emit (D:\hexoblog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:961:16)</span><br><span class="line">    at Socket.stream.socket.on (internal/child_process.js:380:11)</span><br><span class="line">    at Socket.emit (events.js:182:13)</span><br><span class="line">    at Pipe._handle.close [as _onclose] (net.js:596:12)</span><br></pre></td></tr></table></figure><p>这是错误是因为本地的博客版本与远程的版本不一致，解决方法是删除博客目录下的.deploy_git文件夹，然后克隆远程的仓库到博客目录里面，然后改名字为.deploy_git。</p><h3 id="will-not-add-file-alias"><a href="#will-not-add-file-alias" class="headerlink" title="will not add file alias"></a>will not add file alias</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fatal: will not add file alias 'categories/Python/index.html' ('categories/python/index.html' already exists in index)</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\hexoblog\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:182:13)</span><br><span class="line">    at ChildProcess.cp.emit (D:\hexoblog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:961:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:248:5)</span><br></pre></td></tr></table></figure><p>解决办法，把 <code>./deploy_git/.git/config</code> 里面的 ignorecase 值改成 false</p><h3 id="评论丢失"><a href="#评论丢失" class="headerlink" title="评论丢失"></a>评论丢失</h3><p>评论是保存在 LeanCloud 的，由于 LeanCloud 服务升级，代码丢失无法按期修改 appid 和 appkey，之前的评论数据全部丢失了，现在的评论是重开的。</p><h3 id="兄弟站点"><a href="#兄弟站点" class="headerlink" title="兄弟站点"></a>兄弟站点</h3><p>已于 2022 年初新开兄弟站点 <a href="https://buyixiao.github.io/" target="_blank" rel="noopener">https://buyixiao.github.io/</a>，更多有趣好玩实用的 tools，欢迎来玩</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两年多没有更新网站了，这两年，我完成了从一名大厂工程师到连续创业者的转变。
    
    </summary>
    
      <category term="hexo" scheme="https://inspurer.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://inspurer.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://inspurer.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>原创爬虫大全</title>
    <link href="https://inspurer.github.io/2020/12/03/%E5%8E%9F%E5%88%9B%E7%88%AC%E8%99%AB%E5%A4%A7%E5%85%A8/"/>
    <id>https://inspurer.github.io/2020/12/03/原创爬虫大全/</id>
    <published>2020-12-03T14:52:01.000Z</published>
    <updated>2023-06-28T01:45:29.911Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新网站了，应该快一年了 orz，这一年，我完成了从一名学生到大厂工程师的转变。</p><p>在这期间，陆陆续续的完成了一些爬虫项目，介绍如下，代码获取方式见文末。<a id="more"></a></p><h2 id="微博爬虫"><a href="#微博爬虫" class="headerlink" title="微博爬虫"></a>微博爬虫</h2><p>一个完整爬取 <font size="4" color="red">搜索关键词的微博、用户微博以及评论</font>的爬虫，已经开源在 github 上，地址如下：</p><blockquote><p><a href="https://github.com/Python3Spiders/WeiboSuperSpider" target="_blank" rel="noopener">https://github.com/Python3Spiders/WeiboSuperSpider</a></p></blockquote><h2 id="微信公众号爬虫"><a href="#微信公众号爬虫" class="headerlink" title="微信公众号爬虫"></a>微信公众号爬虫</h2><p>1、可以爬取 <font size="4" color="red">指定公众号所有文章的标题、内容、点赞数、好看数</font></p><p>2、可以爬取 <font size="4" color="red">指定公众号所有视频并下载到本地</font></p><h2 id="知乎爬虫"><a href="#知乎爬虫" class="headerlink" title="知乎爬虫"></a>知乎爬虫</h2><p>1、可以爬取 <font size="4" color="red">指定用户或者机构的所有想法、文章、回答、视频的标题点赞数和评论数</font></p><p>2、可以爬取 <font size="4" color="red">指定问题下的所有回答，爬取指定回答下的所有评论</font></p><h2 id="链家爬虫"><a href="#链家爬虫" class="headerlink" title="链家爬虫"></a>链家爬虫</h2><p>可以爬取 <font size="4" color="red">指定城市的所有租房、成交房以及二手房数据，包含多达十个字段</font>，没有任何敏感信息，仅做数据分析用</p><h2 id="facebook-爬虫"><a href="#facebook-爬虫" class="headerlink" title="facebook 爬虫"></a>facebook 爬虫</h2><p>可以 <font size="4" color="red">爬取指定用户的帖子</font></p><h2 id="instagram-爬虫"><a href="#instagram-爬虫" class="headerlink" title="instagram 爬虫"></a>instagram 爬虫</h2><p>1、可以爬取 <font size="4" color="red">指定用户的粉丝信息，关注信息</font></p><p>2、可以 <font size="4" color="red">下载指定用户的所有图片</font></p><h2 id="youtube-爬虫"><a href="#youtube-爬虫" class="headerlink" title="youtube 爬虫"></a>youtube 爬虫</h2><p>可以爬取 <font size="4" color="red">指定视频的所有评论</font></p><h2 id="bilibili-爬虫"><a href="#bilibili-爬虫" class="headerlink" title="bilibili 爬虫"></a>bilibili 爬虫</h2><p>1、可以下载指定视频</p><p>2、可以爬取指定视频的所有评论和弹幕</p><h1 id="如何获取源码"><a href="#如何获取源码" class="headerlink" title="如何获取源码"></a>如何获取源码</h1> <font size="4" color="red">除了第一个微博爬虫，其余都没有开源，如有需要可通过关注公众号【月小水长】后台联系我。</font><p>#微信公众号爬虫、#知乎爬虫、#链家爬虫、#facebook 爬虫、#微博爬虫</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有更新网站了，应该快一年了 orz，这一年，我完成了从一名学生到大厂工程师的转变。&lt;/p&gt;
&lt;p&gt;在这期间，陆陆续续的完成了一些爬虫项目，介绍如下，代码获取方式见文末。
    
    </summary>
    
      <category term="爬虫" scheme="https://inspurer.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="新浪微博" scheme="https://inspurer.github.io/tags/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/"/>
    
      <category term="微信公众号文章/视频" scheme="https://inspurer.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0-%E8%A7%86%E9%A2%91/"/>
    
      <category term="链家" scheme="https://inspurer.github.io/tags/%E9%93%BE%E5%AE%B6/"/>
    
      <category term="知乎" scheme="https://inspurer.github.io/tags/%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
  <entry>
    <title>刘媛媛：年轻人能为世界做什么</title>
    <link href="https://inspurer.github.io/2019/04/26/%E5%88%98%E5%AA%9B%E5%AA%9B%EF%BC%9A%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%83%BD%E4%B8%BA%E4%B8%96%E7%95%8C%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>https://inspurer.github.io/2019/04/26/刘媛媛：年轻人能为世界做什么/</id>
    <published>2019-04-26T14:47:37.000Z</published>
    <updated>2019-04-26T15:01:11.837Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><iframe src="//player.bilibili.com/player.html?aid=8907090&cid=14699912&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></p><a id="more"></a><p>我是一名法学院的学生，我的每一门课的教授都曾经在他的课堂上讲过这么一句话，他们常常“说法律是这么规定的，但是现实生活中„„”现实生活是一种很神奇的生活，在现实生活中那些尊重规则的老实人往往一辈子都默默无闻，反倒是那些弄虚作假的人到最后会名利双收，于是乎像我这样的年轻人就经常有那些看着很有经验的前辈过来拍拍你的肩膀跟你说“年轻人你还不懂。”我想问的是我们年轻人你能为这个世界做什么，总有一天银行行长会是九零后，企业家会是九零后，甚至国家主席都会是九零后，当全社会都被九零后占领的时候，我想问你们九零后们，大家想把这个社会变成什么样。</p><p>我知道不是每一个人他都能够成为那种站在风口浪尖上去把握国家命运的人物，你我都是再普通不过的升斗小民，是这个庞大的社会机器上一颗小小的螺丝钉，读书的时候每天都被父母耳提面命说你干啥你都不要给我耽误学习；毕业的时候到处投简历，凄凄惶惶的等一家企业收留自己；逢年过节被逼婚，结婚买了房子要花自己年轻的时候的最好的二十年来偿还贷款，让每一个年轻人都忙着生存，而没有梦想，没有时间关心政治，没有时间关心环境，没有时间关心国家的命运，还哪有什么精力去为这社会做什么，但是后来我发现还是有一件事情你跟我都可以做到，这件事情就是我们这一代人在我们老去的路上，一定一定不要变坏，不要变成你年轻的时候最痛恨、最厌恶的那种成年人。如果将来你去路边摆摊，你就不要卖地沟油小吃，你不要缺斤短两；你将来开了工厂当了老板，你不要偷工减料，生产一些次品。每一个普通人他在自己普通的岗位上做一个好人是有非常非常严重的意义的，因为我们每一个人生下来都注定会改变世界。</p><p>我是一个学法律的，如果我将来是一个公正严明的法官，那么这个社会就因为多了一个好法官而变好了一点点，我希望大家都记住即使给了你十万个理由让你去作恶，你都要保持自己的操守跟底线，仅仅就因为一个理由，这个理由就是你不是一个禽兽，你是一个人。我更希望我们所有的九零后们，你们都能成为那种难能可贵的年轻人，一辈子都嫉恶如仇，绝不随波逐流，你绝不摧眉折腰，你绝不摧眉折腰，你绝不放弃自己的原则，你绝不绝不绝不失望于人性。所以我亲爱的九零后们，如果将来再是有那些人跟你说“年轻人你不要看不惯，你要适应这个社会。”这时候你就应该像一个真正的勇士一样直面他，你告诉他“我跟你不一样，我不是来适应社会的，我是来改变社会的。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;br&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=8907090&amp;cid=14699912&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="演讲" scheme="https://inspurer.github.io/tags/%E6%BC%94%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>刘媛媛：寒门贵子</title>
    <link href="https://inspurer.github.io/2019/04/26/%E5%88%98%E5%AA%9B%E5%AA%9B%EF%BC%9A%E5%AF%92%E9%97%A8%E8%B4%B5%E5%AD%90/"/>
    <id>https://inspurer.github.io/2019/04/26/刘媛媛：寒门贵子/</id>
    <published>2019-04-26T13:59:18.000Z</published>
    <updated>2019-04-26T15:01:35.444Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><iframe src="//player.bilibili.com/player.html?aid=21818108&cid=36003102&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br></p><a id="more"></a><p>在这个演讲开始之前，我先问问现场的大家一个问题，你们当中有谁觉得自己是家境普通，甚至出身贫寒，将来想要出人头地只能靠自己？你们当中又有谁觉得自己是有钱人家的小孩儿，起码在奋斗的时候可以从父母那里得到一点助力？</p><p>前些日子，有一个在银行工作了十年的HR（人力资源管理师），他在网络上发了一篇帖子，叫做《寒门再难出贵子》。意思是说在当下，我们这个社会里面，寒门的小孩儿他想要出人头地，想要成功，比我们父辈的那一代更难了。这个帖子引起了特别广泛的讨论，你们觉得这句话有道理吗？</p><p>先拿我自己说，我们家就是出身寒门的，我们家都不算寒门，我们家有没有门。我现在想想我都不知道，当初我爸跟我妈那么普通的农村夫妇，他是怎么样把三个孩子，我跟我两个哥，从农村供出来上大学，上研究生。我一直都觉得自己特别幸运，我爸跟我妈都没怎么读过书，我妈连小学一年级都没上过，她居然觉得读书很重要，她吃再多的苦，也要让我们三个孩子上大学。</p><p>我一直也不会拿自己跟那些，比如家庭富裕的小孩儿去做计较，我说们之间会有什么不同，或者有什么不平等，但是我们必须要承认这个世界是有一些不平等的，他们有很多优越的条件，我们都没有，他们有很多的捷径我们也没有，可是我们不能抱怨，每一个人的人生都是不尽相同的，有些人出生就含着金钥匙，有些人出生连爸妈都没有。</p><p>人生和人生是没有可比性的，我们的人生是怎么样，完全取决于自己的感受，你一辈子都在感受抱怨，那你的一生就是抱怨的一生，你一辈子都在感受感动，那你的一生就是感动的一生，你一辈子都立志于改变这个社会，那你的一生就是一个斗士的一生。</p><p>英国有一部纪录片，叫做《人生七年》，片中访问了十二个来自不同阶层的七岁小孩儿，每七年再去重新访问这些小孩儿到了影片的最后就发现，富人的孩子还是富人，穷人的孩子还是穷人，但是里面有一个叫尼克的贫穷的小孩儿，他到最后通过自己的奋斗变成了一名大学教授，可见命运的手掌里面是有漏网之鱼的。而且，现实生活中寒门子弟逆袭的例子更是数不胜数。</p><p>所以当我们遭受失败的时候，我们不能把所有的原因都归结到出生上去，更不能抱怨自己的父母为什么不如别人的父母，因为家境不好，并没有斩断一个人他成功的所有的可能。</p><p>当我在人生终于到很大的困难的时候，我就会在北京的大街上走一走，看着人来人往，而那时候我就想，刘媛媛，你在这个城市里面真的是一无所依，你有的只是你自己你什么都没有，你现在能做的就是单枪匹马的，在这个社会上杀出一条路来。（掌声！）</p><p>这段演讲到现在已经是最后一次了，其实在刚刚我问的时候就发现了，我们大部分人都不是出生豪门的，我们都要靠自己，所以你要相信，命运给你一个比别人低的起点，是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事。</p><p>这个故事关于独立，关于梦想，关于勇气，关于坚忍，它不是一个水到渠成的童话，没有一点人间疾苦，这个事故是有志者事竟成，破釜沉舟，百二秦关终属楚；这个故事是苦心人天不负，卧薪尝胆，三千越甲可吞吴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;br&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=21818108&amp;cid=36003102&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="演讲" scheme="https://inspurer.github.io/tags/%E6%BC%94%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>小程序 wx.authorize 之 scope.userLocation 授权错误</title>
    <link href="https://inspurer.github.io/2019/04/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F-wx-authorize-%E4%B9%8B-scope-userLocation-%E6%8E%88%E6%9D%83%E9%94%99%E8%AF%AF/"/>
    <id>https://inspurer.github.io/2019/04/14/小程序-wx-authorize-之-scope-userLocation-授权错误/</id>
    <published>2019-04-14T08:54:09.000Z</published>
    <updated>2019-04-14T09:01:22.060Z</updated>
    
    <content type="html"><![CDATA[<p>今天做的一个小程序项目中需要用到<code>scope.userLocation</code><strong>获取用户地理位置</strong>这个权限<a id="more"></a>，这个权限对应两个接口<code>wx.getLocation(Object object)</code> 和<code>wx.chooseLocation(Object object)</code>，这两个接口都能够获取到用户当前位置的经纬度，但是除此之外，<code>wx.getLocation(Object object)</code>还能获都速度、高度、经纬度的精确度等更多专业的地理信息；<code>wx.chooseLocation(Object object)</code>则更加通俗化一些，通过这个接口，我们可以获得具体的地理名称，比如某某街道xx号这样的，看到网上有很多关于获取地理名称的教程是先通过<code>wx.getLocation(Object object)</code>获取经纬度，再由第三方 API 解析成地理名称，这样未免太麻烦了，可能是不知道<code>wx.chooseLocation(Object object)</code>的存在。</p><p>我的思路是直接调用<code>wx.chooseLocation(Object object)</code>,如果成功，则在它的回调函数<code>success</code>中直接获取地理名称，如果失败，则是由于还没有授权造成的，我们就在回调函数<code>fail</code>中获得授权然后再调用<code>wx.chooseLocation(Object object)</code>即可，一旦同意授权，除非你删除这个小程序，否则授权的有效性是一直存在的，下次直接调用<code>wx.chooseLocation(Object object)</code>就能成功回调。这部分代码如下:</p><pre><code>wx.chooseLocation({    success: function(res) {      console.log(&apos;succes1&apos;)      console.log(res)      that.setData({        addr: res.address //调用成功直接设置地址      })    },    fail: function() {      wx.getSetting({        success(res) {          if (!res.authSetting[&apos;scope.userLocation&apos;]) {            console.log(&quot;f1&quot;)            wx.authorize({              scope: &apos;scope.userLocation&apos;,              success() {                wx.chooseLocation({                  success: function(res) {                    that.setData({                      addr: res.address //调用成功直接设置地址                    })                  },                })                console.log(&apos;success2&apos;)              },              fail(){                console.log(&quot;f2&quot;)              }            })          }        }      })    }  })</code></pre><p>但是，问题来了，这部分代码在电脑开发工具上一直可以按照预期结果运行，可是一旦放到手机上，就千奇百怪，大概一百次只有一次是按照预期结果运行的，其他的全部没有成功调出地图获取用户当前位置（我也好奇为什么会有一次成功？？？）。我查阅了官方文档，才发现，原来<code>scope.userLocation</code>这个权限比较特别，必须要在<font size="5" color="red">app.json</font>文件中声明这个权限是用来干吗的。如下：</p><pre><code>&quot;permission&quot;: {  &quot;scope.userLocation&quot;: {    &quot;desc&quot;: &quot;需要记录打卡时的位置信息&quot;  }},</code></pre><p>注意看下图中的描述就是代码中的 <code>desc</code>:description</p><p align="center"><br><img src="https://s2.ax1x.com/2019/04/14/AO7vKe.jpg" height="580px" width="300px"><br></p><p>加了之后，症状就解除了。</p><p>欢迎留言，欢迎关注微信公众号： <font size="5" color="red">月小水长</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天做的一个小程序项目中需要用到&lt;code&gt;scope.userLocation&lt;/code&gt;&lt;strong&gt;获取用户地理位置&lt;/strong&gt;这个权限
    
    </summary>
    
      <category term="小程序" scheme="https://inspurer.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="https://inspurer.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="authorize" scheme="https://inspurer.github.io/tags/authorize/"/>
    
      <category term="userLocation" scheme="https://inspurer.github.io/tags/userLocation/"/>
    
  </entry>
  
  <entry>
    <title>wxPython 开发实战之输入控件 TextCtrl 使用验证器 Validator 来约束输入</title>
    <link href="https://inspurer.github.io/2019/04/12/wxPython-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E4%B9%8B%E8%BE%93%E5%85%A5%E6%8E%A7%E4%BB%B6-TextCtrl-%E4%BD%BF%E7%94%A8%E9%AA%8C%E8%AF%81%E5%99%A8-Validator-%E6%9D%A5%E7%BA%A6%E6%9D%9F%E8%BE%93%E5%85%A5/"/>
    <id>https://inspurer.github.io/2019/04/12/wxPython-开发实战之输入控件-TextCtrl-使用验证器-Validator-来约束输入/</id>
    <published>2019-04-12T06:43:18.000Z</published>
    <updated>2019-04-12T06:47:26.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TextCtrl 是 wxPython 框架里一个非常实用的文本输入控件，我们经常需要对 TextCtrl 做这样一个输入上的约束：只允许输入数字<a id="more"></a> （比如允许 1.2、4.5、100 这些输入而禁止诸如 .8、4t等输入，方便我们在将输入的 str 类型转成 int、float 等其他类型时不需要额外加判断来防止产生异常。今天我查阅 wxPython 的 API,发现了 Validator 这个类可以满足我们的需求。事实上，不仅是满足只允许输入数字这个需要，掌握了 Validator 这个类的使用，我们可以满足任何定制化的需求。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h4 id="首先必须新建类继承自-wx-Validator"><a href="#首先必须新建类继承自-wx-Validator" class="headerlink" title="首先必须新建类继承自 wx.Validator"></a>首先必须新建类继承自 wx.Validator</h4><pre><code>import wxclass MyNumberValidator(wx.Validator):# 创建验证器子类          def __init__(self):        wx.Validator.__init__(self)    def Clone(self):        return MyNumberValidator()    def Validate(self,win):#1 使用验证器方法        return True    def TransferToWindow(self):        return True    def TransferFromWindow(self):        return True</code></pre><p>同时，必须重写 <strong>init</strong>()(完成初始化）、Clone()(返回当前类的一个实例）等五个方法，你只要把它们当成一个模板就行，然后在此基础上加上我们自己的逻辑。</p><h4 id="根据需求加入实现逻辑"><a href="#根据需求加入实现逻辑" class="headerlink" title="根据需求加入实现逻辑"></a>根据需求加入实现逻辑</h4><pre><code>import wx# import wx.lib.imagebrowserclass MyNumberValidator(wx.Validator):# 创建验证器子类          def __init__(self):        wx.Validator.__init__(self)        self.ValidInput = [&apos;.&apos;,&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;]        self.StringLength = 0        self.Bind(wx.EVT_CHAR,self.OnCharChanged)  #  绑定字符改变事件    def OnCharChanged(self,event):        # 得到输入字符的 ASCII 码        keycode = event.GetKeyCode()        # 退格（ASCII 码 为8），删除一个字符。        if keycode == 8:            self.StringLength -= 1            #事件继续传递            event.Skip()            return        # 把 ASII 码 转成字符        InputChar = chr(keycode)        if InputChar in self.ValidInput:            # 第一个字符为 .,非法，拦截该事件，不会成功输入            if InputChar == &apos;.&apos; and self.StringLength == 0:                return False            # 在允许输入的范围，继续传递该事件。            else:                event.Skip()                self.StringLength += 1                return True        return False    def Clone(self):        return MyNumberValidator()    def Validate(self,win):#1 使用验证器方法        return True    def TransferToWindow(self):        return True    def TransferFromWindow(self):        return True</code></pre><p>注意这行代码，<code>self.Bind(wx.EVT_CHAR,self.OnCharChanged)  #  绑定字符输入事件</code>,它的意思是，一旦用户输入了字符，该事件会首先交给<code>OnCharChanged</code>方法处理，在<code>OnCharChanged</code>中，特别注意<code>event.Skip()</code>这行代码，它的意思是，过了合法性检验这一关，该事件可以继续传递了，可以交给将该字符加入 textctrl.value 并显示出来的函数处理；否则，事件就在<code>OnCharChanged</code>中被拦截了，不会显示出来，输入失败。</p><h3 id="给控件-textctrl-绑定验证器子类。"><a href="#给控件-textctrl-绑定验证器子类。" class="headerlink" title="给控件 textctrl 绑定验证器子类。"></a>给控件 textctrl 绑定验证器子类。</h3><p>很简单，只需要在创建 textctrl 的时候加指定关键词参数</p><pre><code>wx.TextCtrl(self,validator=MyNumberValidator(),style=wx.TE_CENTER)</code></pre><p><code>style=wx.TE_CENTER</code> 使输入字符居中</p><h3 id="再说-Validate-方法"><a href="#再说-Validate-方法" class="headerlink" title="再说 Validate() 方法"></a>再说 Validate() 方法</h3><p>我们发现，<code>Validator</code> 类中和类名最相似的方法<code>Validate()</code>一直没有使用，其实这个方法是一般使用流程如下，先在 <code>Validate()</code> 方法中加上业务逻辑。</p><pre><code>def Validate(self,win):#1 使用验证器方法       print(111)       textCtrl = self.GetWindow()       text = textCtrl.GetValue()       valid_text = &apos;&apos;       for i in text:           if i in self.ValidInput:               valid_text += i       textCtrl.SetValue(valid_text)       return True</code></pre><p>然后在外部调用它验证合法性</p><pre><code>self.n1.GetValidator().Validate(self.n1)</code></pre><p>Validate()也可以验证合法性，只不过它不能处理输入事件，必须在输入完成后才能验证合法性，相当于“马后炮”的作用。</p><h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><p><img src="https://s2.ax1x.com/2019/04/12/Ab2c9I.gif" alt=""></p><pre><code># -*- coding: utf-8 -*-# author:           inspurer(月小水长)# pc_type           lenovo# create_time:      2019/4/12 13:37# file_name:        validator.py# github            https://github.com/inspurer# qq邮箱            2391527690@qq.com# 微信公众号         月小水长(ID: inspurer)import wx# import wx.lib.imagebrowserclass MyNumberValidator(wx.Validator):# 创建验证器子类          def __init__(self):        wx.Validator.__init__(self)        self.ValidInput = [&apos;.&apos;,&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;]        self.StringLength = 0        self.Bind(wx.EVT_CHAR,self.OnCharChanged)  #  绑定字符输入事件    def OnCharChanged(self, event):        # 得到输入字符的 ASCII 码        keycode = event.GetKeyCode()        # 退格（ASCII 码 为8），删除一个字符。        if keycode == 8:            self.StringLength -= 1            # 事件继续传递            event.Skip()            return        # 把 ASII 码 转成字符        InputChar = chr(keycode)        if InputChar in self.ValidInput:            # 第一个字符为 .,非法，拦截该事件，不会成功输入            if InputChar == &apos;.&apos; and self.StringLength == 0:                return False            # 在允许输入的范围，继续传递该事件。            else:                event.Skip()                self.StringLength += 1                return True        return False    def Clone(self):        return MyNumberValidator()    def Validate(self,win):#1 使用验证器方法        print(111)        textCtrl = self.GetWindow()        text = textCtrl.GetValue()        valid_text = &apos;&apos;        for i in text:            if i in self.ValidInput:                valid_text += i        textCtrl.SetValue(valid_text)        return True    def TransferToWindow(self):        return True    def TransferFromWindow(self):        return Trueclass GUI(wx.Frame):    def __init__(self,parent):        wx.Frame.__init__(self, parent=parent, title=&quot;wxPython开发实战&quot;,size=(400,300),style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER ^ wx.MAXIMIZE_BOX )        self.Center()        self.SetBackgroundColour(&apos;white&apos;)        font = wx.Font(16,wx.DECORATIVE, wx.NORMAL, wx.NORMAL)        self.n1 = wx.TextCtrl(self,validator=MyNumberValidator(),pos=(100,30),size=(180,45),style=wx.TE_CENTER)        self.n1.SetFont(font)        self.n1.SetBackgroundColour(&apos;#95ec69&apos;)        self.n1.SetHint(&apos;请输入第一个数字&apos;)        self.n2 = wx.TextCtrl(self,validator=MyNumberValidator(),pos=(100,100),size=(180,45),style=wx.TE_CENTER)        self.n2.SetFont(font)        self.n2.SetBackgroundColour(&apos;#95ec69&apos;)        self.n2.SetHint(&apos;请输入第二个数字&apos;)        self.config = wx.Button(self,label=&quot;验证输入框一的合法性&quot;,pos=(115,170),size=(150,40))        self.config.SetBackgroundColour(&apos;#95ec69&apos;)        self.Bind(wx.EVT_BUTTON,self.configClicked,self.config)    def configClicked(self,event):        self.n1.GetValidator().Validate(self.n1)        passif __name__ == &quot;__main__&quot;:    app = wx.App()    GUI(None).Show()    app.MainLoop()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;TextCtrl 是 wxPython 框架里一个非常实用的文本输入控件，我们经常需要对 TextCtrl 做这样一个输入上的约束：只允许输入数字
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="wxPython" scheme="https://inspurer.github.io/tags/wxPython/"/>
    
      <category term="TextCtrl" scheme="https://inspurer.github.io/tags/TextCtrl/"/>
    
      <category term="Validator" scheme="https://inspurer.github.io/tags/Validator/"/>
    
  </entry>
  
  <entry>
    <title>丘吉尔二战演讲</title>
    <link href="https://inspurer.github.io/2019/04/10/%E4%B8%98%E5%90%89%E5%B0%94%E4%BA%8C%E6%88%98%E6%BC%94%E8%AE%B2/"/>
    <id>https://inspurer.github.io/2019/04/10/丘吉尔二战演讲/</id>
    <published>2019-04-10T12:09:12.000Z</published>
    <updated>2019-04-10T12:16:41.352Z</updated>
    
    <content type="html"><![CDATA[<font size="4" color="red">I have nothing to offer but blood, toil, tears and sweat.<a id="more"></a> We have before us an ordeal of the most grievous kind. We have before us many, many months of struggle and suffering.<br><br>我所能奉献的唯有热血、辛劳、眼泪和汗水我们所面临的将是一场极其严酷的考验，将是旷日持久的斗争和苦难。</font><p>You ask, what is our policy? I say it is to wage war by land, sea and air. War with all our might and with all the strength God has given us, and to wage war against a monstrous tyranny never surpassed in the dark and lamentable catalogue of human crime. That is our policy.</p><p>若问我们的政策是什么？我的回答是：在陆上、海上、空中作战。尽我们的全力，尽上帝赋予我们的全部力量去作战，对人类黑暗、可悲的罪恶史上空前凶残的暴政作战。这就是我们的政策。</p><p>You ask, what is our aim? I can answer in one word, It is victory. Victory at all costs-victory in spite of all terrors-victory, however long and hard the road may be, for without victory there is no survival.</p><p>若问我们的目标是什么？我可以用一个词来回答，那就是胜利。不惜一切代价，去夺取胜利–不惧一切恐怖，去夺取胜利–不论前路如何漫长、如何艰苦，去夺取胜利。因为没有胜利就不能生存。</p><p>Let that be realized. No survival for the British Empire, no survival for all that the British Empire has stood for, no survival for the urge, the impulse of the ages, that mankind shall move forward toward his goal.</p><p>我们务必认识到，没有胜利就不复有大英帝国，没有胜利就不复有大英帝国所象征的一切，没有胜利就不复有多少世纪以来的强烈要求和冲动：人类应当向自己的目标迈进。</p><p>I take up my task in buoyancy and hope. I feel sure that our cause will not be suffered to fail among men.</p><p>我精神振奋、满怀信心地承担起我的任务。我确信，大家联合起来，我们的事业就不会遭到挫败。</p><p>I feel entitled at this juncture, at this time, to claim the aid of all and to say, “Come then, let us go forward together with our united strength.”</p><p>在此时此刻的危急关头，我觉得我有权要求各方面的支持。我要说：”来吧，让我们群策群力，并肩前进！”</p>]]></content>
    
    <summary type="html">
    
      &lt;font size=&quot;4&quot; color=&quot;red&quot;&gt;I have nothing to offer but blood, toil, tears and sweat.
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="名人演讲" scheme="https://inspurer.github.io/tags/%E5%90%8D%E4%BA%BA%E6%BC%94%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>2012奥巴马连任成功竞选演讲</title>
    <link href="https://inspurer.github.io/2019/04/10/2012%E5%A5%A5%E5%B7%B4%E9%A9%AC%E8%BF%9E%E4%BB%BB%E6%88%90%E5%8A%9F%E7%AB%9E%E9%80%89%E6%BC%94%E8%AE%B2/"/>
    <id>https://inspurer.github.io/2019/04/10/2012奥巴马连任成功竞选演讲/</id>
    <published>2019-04-10T11:58:09.000Z</published>
    <updated>2019-04-10T12:11:15.525Z</updated>
    
    <content type="html"><![CDATA[<p>2012年奥巴马胜选演讲全文（中英文对照）</p><p>Thank you. Thank you. Thank you so much. <a id="more"></a>(Sustained cheers, applause.) Tonight, more than 200 years after a former colony won the right to determine its own destiny, the task of perfecting our union moves forward. (Cheers, applause.)</p><p>谢谢，谢谢，非常感谢。</p><p>两百多年前，人民在这块曾经的殖民地上赢得了自己的命运；今夜，我们向实现完美联邦的目标又迈近了一步。</p><p>It moves forward because of you. It moves forward because you reaffirmed the spirit that has triumphed over war and depression, the spirit that has lifted this country from the depths of despair to the great heights of hope, the belief that while each of us will pursue our own individual dreams, we are an American family, and we rise or fall together as one nation and as one people. (Cheers, applause.)</p><p>这一步，是因为你们；这一步，是因为你们证明了克服战争和萧条的那种精神仍在，那份把我们国家从绝望的深渊带向希望之巅的精神。我们每个人都可以追逐自己的梦想。 美国同胞血浓于水，作为一个国家和民族，我们共起落、同荣辱。</p><p>Tonight, in this election, you, the American people, reminded us that while our road has been hard, while our journey has been long, we have picked ourselves up, we have fought our way back, and we know in our hearts that for the United States of America, the best is yet to come.</p><p>今晚，在这次选举中，你们，美国人民们，提醒了我们：尽管路程艰辛，历程漫长，我们仍能振作精神，奋起反击。我们心中坚信，美利坚的每天更加美好。</p><p>(Cheers, applause.) I want to thank every American who participated in this election. (Cheers, applause.) Whether you voted for the very first time — (cheers) — or waited in line for a very long time — (cheers) — by the way, we have to fix that. (Cheers, applause.) Whether you pounded the pavement or picked up the phone — (cheers, applause) — whether you held an Obama sign or a Romney sign, you made your voice heard and you made a difference. (Cheers, applause.)</p><p>我想感谢每一位亲身参与大选的美国人。无论这是你的第一次投票，又或是在队伍中等待了很久。顺便说一句，排队这个问题真是亟待解决。无论你是步行前往，还是拿起电话；无论你举的牌子上，写的是奥巴马还是罗姆尼… 你的声音都会被听到，你也一样带来了改变。 I just spoke with Governor Romney and I congratulated him and Paul Ryan on a hard-fought campaign. (Cheers, applause.) We may have battled fiercely, but it’s only because we love this country deeply and we care so strongly about its future. From George to Lenore to their son Mitt, the Romney family has chosen to give back to America through public service. And that is a legacy that we honor and applaud tonight. (Cheers, applause.) In the weeks ahead, I also look forward to sitting down with Governor Romney to talk about where we can work together to move this country forward.</p><p>我刚刚和罗姆尼州长通了话，向他和保罗·瑞安，就这场艰难的战役，表示了我的祝贺。双方的选战之所以惨烈，正是因为我们都如此深爱这个国家，如此关心它的未来。从乔治到兰</p><p>诺夫妇，再到他们的儿子米特，罗姆尼一家选择通过献身公务来报效国家。今晚，我们向这一份宝贵的政治遗产致以我们的敬意和掌声。在未来的几个星期，我还希望能和罗姆尼州长坐下来，讨论在哪些方面，我们可以共同努力，推动这个国家向前。</p><p>I want to thank my friend and partner of the last four years, America’s happy warrior, the best vice president anybody could ever hope for, Joe Biden. (Cheers, applause.)</p><p>我想谢谢我的朋友，我过去四年的搭档，美国的快乐战士—乔·拜登。能有他做副总统。夫复何求。</p><p>And I wouldn’t be the man I am today without the woman who agreed to marry me 20 years ago. (Cheers, applause.) Let me say this publicly. Michelle, I have never loved you more. (Cheers, applause.) I have never been prouder to watch the rest of America fall in love with you too as our nation’s first lady. (Cheers, applause.)</p><p>另外，假如没有那位20年前同意嫁给我的女人，我今天也不可能站在这里。让我告诉所有人吧：米歇尔，我对你的爱，是如此深切。我目睹着我之外的美国人都爱上了你，作为第一夫人的你，我对你的骄傲，也是如此深切。</p><p>Sasha and Malia — (cheers, applause) — before our very eyes, you’re growing up to become two strong, smart, beautiful young women, just like your mom. (Cheers, applause.) And I am so proud of you guys. But I will say that for now, one dog’s probably enough. (Laughter.)</p><p>萨莎和玛利亚(奥巴马的两个女儿)，就在我们的注视下，你们已经成长为两位坚强、智慧、美丽的年轻女士，就像你们的妈妈一样。我真得为你们骄傲。不过我还是要说，一条狗应该已经够了。</p><p>To the best campaign team and volunteers in the history of politics — (cheers, applause) — the best — the best ever — (cheers, applause) — some of you were new this time around, and some of you have been at my side since the very beginning.(Cheers, applause.) But all of you are family. No matter what you do or where you go from here, you will carry the memory of the history we made together. (Cheers, applause.) And you will have the lifelong appreciation of a grateful president. <font size="4" color="red">Thank you for believing all the way — (cheers, applause) — to every hill, to every valley. (Cheers, applause.) You lifted me up the whole day, and I will always be grateful for everything that you’ve done and all the incredible work that you’ve put in. (Cheers, applause.)</font></p><p>至政治史上最好的竞选团队和志愿者们：你们是最好的，最最好的。你们中有些人是新鲜加入，有些人从一开始就与我们共同进退，但你们都是我的家人。无论你在做什么，以后要做什么，你们都能带上这段我们共同创造的历史，以及这位感恩的总统对你们一生的感激。 <font size="4" color="red">谢谢你们的一路坚信，陪我翻过每座丘岭，穿越每座山谷。一路走来，多亏你们的辅佑。 我会永远为你们所付出的一切和所有卓越之至的工作而心怀感激。</font></p><p>I know that political campaigns can sometimes seem small, even silly. And that provides plenty of fodder for the cynics who tell us that politics is nothing more than a contest of egos or the domain of special interests. But if you ever get the chance to talk to folks who turned out at our rallies and crowded along a rope line in a high school gym or — or saw folks working late at a campaign office in some tiny county far away from home, you’ll discover something else.</p><p>我知道有时候政治竞选看起来渺小，甚至愚蠢，这为愤世嫉俗者们提供了很多素材。他们告诉我们，政治不过是为特殊利益集团服务的猴戏。但如果你曾经同参加过我们的集会的普通人，或是在高中体育馆围线外排队的人们交谈过；或是看到在远离家乡的小郡县竞选办公室里工作到很晚的人们，你一定会有新的认识。</p><p>You’ll hear the determination in the voice of a young field organizer who’s working his way through college and wants to make sure every child has that same opportunity. (Cheers, applause.) You’ll hear the pride in the voice of a volunteer who’s going door to door because her brother was finally hired when the local auto plant added another shift. (Cheers, applause.)</p><p>你会在一位半工半读的年轻活动现场组织者声音中，听到无比的坚定。他想让每个孩子都能有均等的机会；你会在一名志愿者声音中，听到他的自豪。她挨家挨户的告诉每一个人，她的哥哥终于有了工作，因为当地的汽车公司增加了一个轮班；</p><p>You’ll hear the deep patriotism in the voice of a military spouse who’s working the phones late at night to make sure that no one who fights for this country ever has to fight for a job or a roof over their head when they come home. (Cheers, applause.)</p><p>你会在一位军嫂声音中听到她的爱国主义情怀。她深夜也不放下电话是为了要让每一位保家卫国的战士，都不用在回家后，却为一份工作、一片屋檐，苦苦求而不得。</p><p>That’s why we do this. That’s what politics can be. That’s why elections matter. It’s not small, it’s big. It’s important. Democracy in a nation of 300 million can be noisy and messy and complicated. We have our own opinions. Each of us has deeply held beliefs. And when we go through tough times, when we make big decisions as a country, it necessarily stirs passions, stirs up controversy. That won’t change after tonight. And it shouldn’t. These arguments we have are a mark of our liberty, and we can never forget that as we speak, people in distant nations are risking their lives right now just for a chance to argue about the issues that matter — (cheers, applause) — the chance to cast their ballots like we did today.</p><p>这就是我们做这些的原因。政治也可以说这样的。这就是为什么，选举是重要的。它并不渺小，它是件大事，很重要的大事。在有三亿人口的国家中，民主会显得喧哗、混乱、复杂。我们有自己的观点，每个人都有自己坚定的信仰。当面对困难的时期，当我们的国家需要作出重大的决定时，它必然会激发热情，也掀起争议。这些在今晚之后都不会改变，也不应该被改变。这些争论是我们自由的印记。我们永远不能忘记，就在此时此刻，在一些遥远的国家，人民正在冒着生命的危险，只为了能有讨论那些重要话题的机会，为了能有像我们今天这样投出自己一票的机会。</p><p>But despite all our differences, most of us share certain hopes for America’s future. We want our kids to grow up in a country where they have access to the best schools and the best teachers — (cheers, applause) — a country that lives up to its legacy as the global leader in technology and discovery and innovation — (scattered cheers, applause) — with all of the good jobs and new businesses that follow.</p><p>We want our children to live in an America that isn’t burdened by debt, that isn’t weakened up by inequality, that isn’t threatened by the destructive power of a warming planet. (Cheers, applause.)</p><p>尽管我们有不同，我们中的大多数，对美国的未来怀有一样的希望。我们希望自己的孩子成长在这样一个国家：他们能去到最好的学校，有最好的老师；它不会辜负前人留下的遗产，继续成为全球科技、探索、创新的领导者，有好的工作、新的产业随之而来；我们希望自己孩子成长的美国，不会被债务负累，不会因不平等而有所削弱，也不会被地球变暖而带来的危害所威胁。</p><p>We want to pass on a country that’s safe and respected and admired around the world, a nation that is defended by the strongest military on earth and the best troops this — this world has ever known — (cheers, applause) — but also a country that moves with confidence beyond this time of war to shape a peace that is built on the promise of freedom and dignity for every human being. 我们想要传承的，是一个安全并受全球尊敬与爱戴的国家。</p><p>我们想要传承的，是一个由世界最强军事力量保卫，拥有最好的军队的国家。同时，也是一个自信前行的国家——走出战争的阴霾，塑造和平景象，保障每个人的自由与尊严。</p><p>We believe in a generous America, in a compassionate America, in a tolerant America open to the dreams of an immigrant’s daughter who studies in our schools and pledges to our flag — (cheers, applause) — to the young boy on the south side of Chicago who sees a life beyond the nearest street corner — (cheers, applause) — to the furniture worker’s child in North Carolina who wants to become a doctor or a scientist, an engineer or an entrepreneur, a diplomat or even a president.</p><p>我们相信美国是一个慷慨大度的国家，一个悲天悯人的国家，更是一个海纳百川的国家。 我们要接纳在我国学校学习并对我们的国旗宣誓，满怀梦想的移民；要接纳身处芝加哥南部市井之中却能志存高远的男孩；还要接纳北卡州家具工人的孩子，他们梦想着成为医生、科学家、工程师、企业家、外交官，甚至是总统。</p><p>That’s the — (cheers, applause) — that’s the future we hope for.</p><p>(Cheers, applause.) That’s the vision we share. That’s where we need to go — forward. (Cheers, applause.) That’s where we need to go. (Cheers, applause.)</p><p>那正是我们所期望的未来，是我们共有的愿景，是我们需要”前进”的方向，那是我们的目标。 Now, we will disagree, sometimes fiercely, about how to get there. As it has for more than two centuries, progress will come in fits and starts. It’s not always a straight line. It’s not always a smooth path. By itself, the recognition that we have common hopes and dreams won’t end all the gridlock, resolve all our problems or substitute for the painstaking work of building consensus and making the difficult compromises needed to move this country forward.</p><p>对于如何实现这一目标，我们可能会意见相左，有时分歧甚大，两个多世纪以来，一直如此。 我们总会断断续续地取得进步，前行的路线总有曲折，不会一直是平坦通途。</p><p>认识到我们拥有共同的希望与梦想，单靠这一点无法终结所有的政治僵局，或解决我们所有问题。建立共识，作出推动这个国家向前所必要的艰难妥协，这些艰辛的工作也无法得以替代。</p><p>But that common bond is where we must begin. Our economy is recovering. A decade of war is ending. (Cheers, applause.) A long campaign is now over. (Cheers, applause.) And whether I earned your vote or not, I have listened to you. I have learned from you. And you’ve made me a better president. And with</p><p>your stories and your struggles, I return to the White House more determined and more inspired than ever about the work there is to do and the future that lies ahead. (Cheers, applause.)</p><p>但我们必须以这一共同纽带为起点。</p><p>我们的经济正在复苏，为期十年的战争已近尾声，一场漫长的竞选现已结束。</p><p>无论我是否赢得了你的选票，我都倾听了你的呼声，从你身上得到了教益，你使我成长为更优秀的总统。</p><p>带着你们的故事与挣扎，我回到白宫时，对面临的任务与未来，更为坚定，更有激情。 Tonight you voted for action, not politics as usual. (Cheers, applause.) You elected us to focus on your jobs, not ours.</p><p>And in the coming weeks and months, I am looking forward to reaching out and working with leaders of both parties to meet the challenges we can only solve together — reducing our deficit, reforming out tax code, fixing our immigration system, freeing ourselves from foreign oil. We’ve got more work to do. (Cheers, applause.) But that doesn’t mean your work is done.</p><p>今晚，你们投票换来的将会是积极的行动，而不是以往那样的政治游戏。你们选择了我们，是让我们关注你们的就业，而非我们自己的官位。</p><p>在接下来的数周、数月中，我期待着与两党领袖进行接触与合作，共同应对我们必须携手攻克的难关，降低赤字、改革税法、完善移民体系、摆脱对进口石油的依赖…我们还有更多的工作要完成，但这并不意味着你们的任务已经结束。</p><p>The role of citizens in our democracy does not end with your vote. America’s never been about what can be done for us; it’s about what can be done by us together, through the hard and frustrating but necessary work of self- government. (Cheers, applause.) That’s the principle we were founded on. 公民在我们的民主体系中所扮演的角色，并不止于投票。</p><p>美利坚的意义，并不在于别人能为我们做什么，而是在于我们能一起做什么，而这依靠的就是公民自治。这虽然困难而又往往令人灰心，却是不可或缺的。这是我们的建国理念。 This country has more wealth than any nation, but that’s not what makes us rich. We have the most powerful military in history, but that’s not what makes us strong. Our university, our culture are all the envy of the world, but that’s not what keeps the world coming to our shores. What makes America exceptional are the bonds that hold together the most diverse nation on Earth, the belief that our destiny is shared — (cheers, applause) — that this country only works when we accept certain obligations to one another and to future generations, so that the freedom which so many Americans have fought for and died for come with responsibilities as well as rights, and among those are love and charity and duty and patriotism. That’s what makes America great. (Cheers, applause.)</p><p>我们国家的财富多于其他任何国家，可我们的富有并不源于此。 我们有史上最强的军事力量，可这并不是我们力量的源头。 我们的大学，我们的文化，为全世界所钦羡，可这并非吸引各国人民前来我国的根源。</p><p>美国的卓尔不群之根源在于，将全球最为多元化的国家团结起来的纽带，在于信奉我们的命运紧密相连。信奉只有当我们对彼此，对下几代人负起一定责任，我们国家才有希望。美国的卓尔不群之根源，在于无数美国人为之奋斗与献身的自由，这自由背后，既有义务又有权</p><p>利，其中就包括仁爱、慈善、责任和爱国。美国的伟大，就是靠这些精神铸就而成的。 I am hopeful tonight because I have seen this spirit at work in America. I’ve seen it in the family business whose owners would rather cut their own pay than lay off their neighbors and in the workers who would rather cut back their hours than see a friend lose a job. I’ve seen it in the soldiers who re-enlist after losing a limb and in those SEALs who charged up the stairs into darkness and danger because they knew there was a buddy behind them watching their back. (Cheers, applause.) I’ve seen it on the shores of New Jersey and New York, where leaders from every party and level of government have swept aside their differences to help a community rebuild from the wreckage of a terrible storm. (Cheers, applause.)</p><p>我今晚充满希望，因为我目睹了美国上下洋溢着的精神：</p><p>在宁愿扣自己薪水，也不愿裁掉邻里员工的家族企业中；</p><p>在宁愿自己少干些，也不愿让朋友失业的工人们身上；</p><p>在手脚伤残，却仍延长服役年限的士兵身上；</p><p>在海军陆战队员身上，他们无畏地冲上楼梯，冲进黑暗与危险，只因心知有人会照顾他们。 在新泽西与纽约的海岸上也可以见到，各党领袖、各级政府撇开分歧，共同帮助一个社区重建被可怕的风暴摧毁的家园。</p><p>And I saw it just the other day in Mentor, Ohio, where a father told the story of his 8-year-old daughter whose long battle with leukemia nearly cost their family everything had it not been for health care reform passing just a few months before the insurance company was about to stop paying for her care. (Cheers, applause.) I had an opportunity to not just talk to the father but meet this incredible daughter of his. And when he spoke to the crowd, listening to that father’s story, every parent in that room had tears in their eyes because we knew that little girl could be our own.</p><p>前些天，我在俄亥俄州的曼图尔市见到了一位父亲，他跟我讲了他8岁女儿的故事。女儿与白血病的斗争差点使他们倾家荡产，幸好医保改革在保险公司停止支付，其医疗费用前数月得以通过。我不仅与这位父亲进行了交谈，也遇到了他坚强的女儿。当她向听众发言时，在场的每一位父母都眼含热泪。因为我们知道，这个小女孩的遭遇也可能发生在我们的孩子身上。</p><p>And I know that every American wants her future to be just as bright. That’s who we are. That’s the country I’m so proud to lead as your president. (Cheers, applause.)</p><p>And tonight, despite all the hardship we’ve been through, despite all the frustrations of Washington, I’ve never been more hopeful about our future. (Cheers, applause.) I have never been more hopeful about America. And I ask you to sustain that hope.</p><p>我知道每一位美国同胞，都希望她有同样光明的未来。</p><p>这就是我们，这就是我非常自豪地以总统身份领导的国家。</p><p>今晚，纵有我们所经历的磨难，纵有华盛顿诸般挫折，我从未对我们的未来如此充满希望，我从未对美利坚如此充满希望。</p><p>我请求你们，保持这份希望。</p><p>AUDIENCE MEMBER: We got your back, Mr. President!</p><p>PRESIDENT OBAMA: I’m not talking about blind optimism, the kind of hope that just ignores the enormity of the tasks ahead or the road blocks that stand in our path. I’m not talking about the wishful idealism that allows us to just sit on the sidelines or shirk from a fight. I have always believed that hope is that stubborn thing inside us that insists, despite all the evidence to the contrary, that something better awaits us so long as we have the courage to keep reaching, to keep working, to keep fighting. (Cheers, applause.)</p><p>我不是指盲目乐观，无视眼前艰巨任务与障碍的那种希望，我也不是指让我们袖手旁观或逃避斗争的那种一厢情愿的理想主义。</p><p>我一直认为，希望是我们心中顽强不屈的那样东西。</p><p>虽有各种不利证据，却仍坚持有更好的未来等待着我们。只要我们有勇气去不断争取、不断努力、不断奋斗。</p><p>America, I believe we can build on the progress we’ve made and continue to fight for new jobs and new opportunities and new security for the middle class. I believe we can keep the promise of our founding, the idea that if you’re willing to work hard, it doesn’t matter who you are or where you come from or what you look like or where you love (ph). It doesn’t matter whether you’re black or white or Hispanic or Asian or Native American or young or old or rich or poor, abled, disabled, gay or straight. (Cheers, applause.) You can make it here in America if you’re willing to try.</p><p>(Cheers, applause.)</p><p>美利坚，我相信，我们能百尺竿头更进一步，继续奋斗，为中产阶级创造就业、创造机会、创造保障。</p><p>我相信，我们能继续履行国父们的承诺——只要你踏实肯干，你是谁，从哪儿来，什么种族，爱哪里，都不重要。无论你是黑人、白人、西班牙裔、亚裔，还是印第安居民，无论你年轻与否、富有与否、健全与否、性向如何，你都能在美国有所成就，只要你愿意努力。</p><p>I believe we can seize this future together because we are not as divided as our politics suggests. We’re not as cynical as the pundits believe. We are greater than the sum of our individual ambitions and we remain more than a collection of red states and blue states. We are, and forever will be, the United States of America. (Cheers, applause.)</p><p>And together, with your help and God’s grace, we will continue our journey forward and remind the world just why it is that we live in the greatest nation on earth. (Cheers, applause.) Thank you, America. (Cheers, applause.) God bless you. God bless these United States. (Cheers, applause.)</p><p>我相信，我们可以共同把握这一未来。因为有别于政坛所表现的，我们其实并没有那么分裂，我们并不像评论员们所认为的那样愤世嫉俗。我们的伟大，胜于我们个人野心的总和，我们不仅仅是红蓝州的集合。我们现在是，也将永远是，美利坚合众国。</p><p>在你们的帮助下和上帝的眷顾下，我们将继续前进，向全世界昭示，我们为何居于地球上最伟大的国家。</p><p>感谢你们，美利坚的人民们！</p><p>上帝保佑你们！</p><p>上帝保佑美国！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2012年奥巴马胜选演讲全文（中英文对照）&lt;/p&gt;
&lt;p&gt;Thank you. Thank you. Thank you so much.
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="名人演讲" scheme="https://inspurer.github.io/tags/%E5%90%8D%E4%BA%BA%E6%BC%94%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬取 CSDN 博客信息</title>
    <link href="https://inspurer.github.io/2019/04/09/Python-%E7%88%AC%E5%8F%96-CSDN-%E5%8D%9A%E5%AE%A2%E4%BF%A1%E6%81%AF/"/>
    <id>https://inspurer.github.io/2019/04/09/Python-爬取-CSDN-博客信息/</id>
    <published>2019-04-09T01:11:53.000Z</published>
    <updated>2019-04-09T01:15:48.966Z</updated>
    
    <content type="html"><![CDATA[<p>突然闲来无事想要爬取csdn博客，顺便温习下相关技术点。<a id="more"></a></p><h2 id="爬取目标"><a href="#爬取目标" class="headerlink" title="爬取目标"></a>爬取目标</h2><p>以我的csdn主页为例<br><img src="https://s2.ax1x.com/2019/04/09/A5TYBF.md.png" alt=""><br>爬取的主要的数据已经在上用红线图标出来了，主要可分为两部分</p><ol><br><li>所有博客的八个统计数据，原创的博客数、你的粉丝数、博客获得的赞、博客的评论数、博客等级、访问量、积分和排名</li><br><li>每篇博客的具体信息，如标题、发布时间、阅读数、评论数</li><br></ol><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>Google Chrome浏览器F12开发者工具查看网页结构，比较简单，如下图所示<br><img src="https://s2.ax1x.com/2019/04/09/A5Tt74.md.png" alt=""><br>csdn网站虽然是一个技术性博客，但是貌似它的反爬措施做的不那么优秀，举个例子，我在分析网页结构的过程中发现它的评论数不是通过Ajax动态渲染的，而新浪新闻做到了这一点，也许是因为新闻类的实时性要求较高而技术博客类没这个必要吧。</p><h2 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h2><h4 id="Requests库获取网页"><a href="#Requests库获取网页" class="headerlink" title="Requests库获取网页"></a>Requests库获取网页</h4><p>我看到许多爬虫教程都是用的urllib2等比较过时的爬虫库来获取网页信息，一来python2马上停止支持，python2时代的urllib2的凸现出来的毛病会越来越多且无法得到官方的修复；二来无论是基于python2的ulilib2还是python3的urllib3，过程都稍显繁琐，不如requests库简明，而且urllib2/3能做的requests都能做，干嘛不用requests呢？</p><blockquote><p>requests.get(url=myUrl,headers=headers).text  </p></blockquote><p>get()接收两个关键字参数，第一个就是我们要爬取网页的URL,第二个就是请求头，用于模拟浏览器访问服务器，不然csdn的服务器会拒绝连接，不懂的可以百度补一下计算机网络相关知识。</p><p>get()返回的是一个<code>requests.models.Response</code>对象，通过它的text属性可以得到网页的源码，字符串类型，这样以后我们就能通过方便地解析网页获取我们想要的信息了。</p><h4 id="pyqeury库解析网页"><a href="#pyqeury库解析网页" class="headerlink" title="pyqeury库解析网页"></a>pyqeury库解析网页</h4><p>其实解析网页最直接的办法是利用<code>re</code>这个库写正则表达式提取信息，优点是正则是万能的，所有的字符串提取都可以通过字符串提取，只有改变匹配的规则就行了，不过缺点是学习起来费劲（最好还是要掌握的，毕竟每个语言的匹配规则都是类似的，在java学的匹配规则照样可以用在python中，只是语法不同，API稍有差异）</p><p>第三方解析库有BeautifulSoup、lxml、pyquery等，学习这些库前最好已经掌握css选择器的一些语法规则，再学这些解析库就事半功倍了，个人感觉最好用的是pyquery库。安装pyquery需要在在命令行下输入：</p><blockquote><p>pip istall pyquery</p></blockquote><p>拿到网页源码后，通过</p><blockquote><p>doc = pq(myPage)  </p></blockquote><p>得到一个<code>pyquery.pyquery.PyQuery</code>对象，其中参数就是网页源码  </p><p>然后可以通过</p><blockquote><p>doc(“aside .data-info dl”).items()</p></blockquote><p>来得到aside标签下class为data-info的标签下的所有dl标签，返回的仍是一个<code>pyquery.pyquery.PyQuery</code>对象，如果dl的标签不止一个，我们可以通过.items()把这个对象转乘一个生成器，通过<code>for a in b</code>来迭代获取每一个dl标签，同样地，迭代出来的每一个子项还是<code>pyquery.pyquery.PyQuery</code>对象。</p><p>下面是pyquery常见的api<br>|名称|功能|<br>|:—:|:—:|<br>|attr(key)|得到标签下属性key的属性值，字符串类型|<br>|parent()/children()|得到标签的父/子标签|<br>|text()|得到标签的文本|</p><p>更多的api可以参考:<a href="https://pythonhosted.org/pyquery/" target="_blank" rel="noopener">pyqeury官方教程</a>  </p><p>另外的，假设一个<code>pyquery.pyquery.PyQuery</code>对象a，通过a(“li”),可以对a里的li标签再选择，所以这种选择过程可以是多重嵌套的，一个容易忘记的选择器语法是a(“[b=c]”),用来选择a标签下属性b的属性值为c的所有标签。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>如下图所示，所有的功能目标已经实现<br><img src="https://s2.ax1x.com/2019/04/09/A5TdhR.md.png" alt=""></p><p>其中csdn id就是想要爬取博主的id，可以去博主的主页看</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>2019/01/21，代码如下: </p><p>代码最新更新在我的github：<a href="https://github.com/inspurer/PythonSpider/tree/master/csdn" target="_blank" rel="noopener">python爬虫集合之csdn爬虫</a>  </p><p>同时可以关注我的csdn爬虫专栏:<a href="https://blog.csdn.net/ygdxt/column/info/30335" target="_blank" rel="noopener">python3爬虫实战</a></p><p>感谢支持！</p><pre><code># -*- coding: utf-8 -*-# author:           inspurer(月小水长)# pc_type           lenovo# create_date:      2019/1/21# file_name:        csdn# qq_mail           2391527690@qq.comimport requestsfrom pyquery import PyQuery as pq# 当前的博客列表页号page_num = 1account = str(input(&apos;print csdn id:&apos;))#account = &quot;ygdxt&quot;# 首页地址baseUrl = &apos;http://blog.csdn.net/&apos; + account# 连接页号，组成爬取的页面网址myUrl = baseUrl + &apos;/article/list/&apos; + str(page_num)headers = {&apos;User-Agent&apos;: &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;}# 构造请求# 访问页面myPage = requests.get(myUrl,headers=headers).textdoc = pq(myPage)data_info = doc(&quot;aside .data-info dl&quot;).items()for i,item in enumerate(data_info):    if i==0:        print(&quot;原创:&quot;+item.attr(&quot;title&quot;))    if i==1:        print(&quot;粉丝:&quot;+item.attr(&quot;title&quot;))    if i==2:        print(&quot;喜欢:&quot;+item.attr(&quot;title&quot;))    if i==3:        print(&quot;评论:&quot;+item.attr(&quot;title&quot;))grade_box = doc(&quot;.grade-box dl&quot;).items()for i,item in enumerate(grade_box):    if i==0:        childitem = item(&quot;dd &gt; a&quot;)        print(&quot;等级:&quot;+childitem.attr(&quot;title&quot;)[0:2])    if i==1:        childitem = item(&quot;dd&quot;)        print(&quot;访问:&quot;+childitem.attr(&quot;title&quot;))    if i==2:        childitem = item(&quot;dd&quot;)        print(&quot;积分:&quot;+childitem.attr(&quot;title&quot;))    if i==3:        print(&quot;排名:&quot;+item.attr(&quot;title&quot;))# 获取每一页的信息while True:    # 首页地址    baseUrl = &apos;http://blog.csdn.net/&apos; + account    # 连接页号，组成爬取的页面网址    myUrl = baseUrl + &apos;/article/list/&apos; + str(page_num)    # 构造请求    myPage = requests.get(myUrl,headers=headers).text    if len(myPage) &lt; 30000:        break    print(&apos;-----------------------------第 %d 页---------------------------------&apos; % (page_num,))    doc = pq(myPage)    articles = doc(&quot;.article-list &gt; div&quot;).items()    articleList = []    for i,item in enumerate(articles):        if i == 0:            continue        title = item(&quot;h4 &gt; a&quot;).text()[2:]        date = item(&quot;p &gt; .date&quot;).text()        num_item = item(&quot;p &gt; .read-num&quot;).items()        ariticle = [date, title]        for j,jitem in enumerate(num_item):            if j == 0:                read_num = jitem.text()                ariticle.append(read_num)            else:                comment_num = jitem.text()                ariticle.append(comment_num)        articleList.append(ariticle)    for item in articleList:        if(len(item)==4):            print(&quot;%s %s %s %s&quot;%(item[0],item[1],item[2],item[3]))page_num = page_num + 1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然闲来无事想要爬取csdn博客，顺便温习下相关技术点。
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="CSDN" scheme="https://inspurer.github.io/tags/CSDN/"/>
    
  </entry>
  
  <entry>
    <title>Python 实现自动化翻译和替换的脚本</title>
    <link href="https://inspurer.github.io/2019/04/08/Python-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BF%BB%E8%AF%91%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>https://inspurer.github.io/2019/04/08/Python-实现自动化翻译和替换的脚本/</id>
    <published>2019-04-08T11:38:14.000Z</published>
    <updated>2019-04-08T11:51:45.837Z</updated>
    
    <content type="html"><![CDATA[<p>妈妈再也不用担心我的英语了。<a id="more"></a></p><h2 id="一个可能你似曾相识的场景"><a href="#一个可能你似曾相识的场景" class="headerlink" title="一个可能你似曾相识的场景"></a>一个可能你似曾相识的场景</h2><p>阅读内容包含大量英文的 PPT、Word、Excel 或者记事本时，由于英语不熟悉，为了流利地阅读，需要打开浏览器进入谷歌翻译的主界面，然后把英文复制到谷歌翻译的输入框中，最后又把翻译结果复制回 PPT、Word 和 Excel。</p><p><img src="https://s2.ax1x.com/2019/04/08/A5MBQA.md.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/04/08/A5MrLt.md.png" alt=""></p><p>要是一个两个单词还好，要是发现有 100 个单词不认识，就必须复制粘贴 200 次，如此机械性重复性的工作，应该交给程序来做，这就是我设计下面这个自动化翻译工具的初衷。</p><h2 id="提升办公效率的法宝"><a href="#提升办公效率的法宝" class="headerlink" title="提升办公效率的法宝"></a>提升办公效率的法宝</h2><p><img src="https://s2.ax1x.com/2019/04/08/A5MyeP.md.gif" alt=""></p><p>如上图，运行程序并保持后台运行，在电脑上的任何一个软件中选择一段文本，并 Ctrl + C 复制到系统剪贴板中，程序就会自动帮助我们完成翻译，并将翻译结果自动复制到系统剪贴版中，只需 Ctrl + V，就完成了翻译结果对原文的替换。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>程序主要分为两部分，第一部分为谷歌翻译爬虫，第二部分就是实现这个将翻译结果自动替换的业务逻辑。</p><h4 id="谷歌翻译爬虫"><a href="#谷歌翻译爬虫" class="headerlink" title="谷歌翻译爬虫"></a>谷歌翻译爬虫</h4><p>通过浏览器 F12 开发者工具，很容易定位到翻译请求的 URL: <code>http://translate.google.cn/translate_a/single?client=t&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=ss&amp;dt=t&amp;ie=UTF-8&amp;oe=UTF-8&amp;clearbtn=1&amp;otf=1&amp;pc=1&amp;srcrom=0&amp;ssel=0&amp;tsel=0&amp;kc=2</code></p><p>这个请求接受两个参数，一个就是我们要翻译的字符串 q，另一个是用于用户认证的 tk(token),其中 q 很容易构造，tk 的构造就需要花费一番心力了，需要我们调试 js 代码，这里参考 Github 上大神的轮子： <a href="https://github.com/cocoa520/Google_TK" target="_blank" rel="noopener">https://github.com/cocoa520/Google_TK</a></p><p>谷歌翻译爬虫的主要代码如下:</p><pre><code>def translate(tk, content):    if len(content) &gt; 4891:        print(&quot;翻译的长度超过限制！！！&quot;)        return    param = {&apos;tk&apos;: tk, &apos;q&apos;: content}    result = requests.get(&quot;&quot;&quot;http://translate.google.cn/translate_a/single?client=t&amp;sl=en        &amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=ss        &amp;dt=t&amp;ie=UTF-8&amp;oe=UTF-8&amp;clearbtn=1&amp;otf=1&amp;pc=1&amp;srcrom=0&amp;ssel=0&amp;tsel=0&amp;kc=2&quot;&quot;&quot;, params=param)    data = result.json()    print(data[0][0][0])</code></pre><p>返回结果是 json 形式的，翻译结果保存在结果的第一个元组中。</p><h4 id="Python-操作系统剪贴板"><a href="#Python-操作系统剪贴板" class="headerlink" title="Python 操作系统剪贴板"></a>Python 操作系统剪贴板</h4><p>将读取剪贴板的内容的代码封装成函数如下：</p><pre><code>def getText():#读取剪切板    # 打开剪贴板    w.OpenClipboard()    # 读取剪贴板的内容    d = w.GetClipboardData(win32con.CF_TEXT)    # 关闭剪贴板    w.CloseClipboard()    try:        return d.decode(&apos;utf-8&apos;)    except:        return d.decode(&apos;gbk&apos;)</code></pre><p>返回值 d 是字节类型的，需要解码，中文按 gbk 格式解码，英文按 utf-8 解码。</p><p>类似地，写入剪贴板的代码如下：</p><pre><code>def setText(aString):#写入剪切板    # 打开剪贴板    w.OpenClipboard()    # 清空剪贴板    w.EmptyClipboard()    # 写入剪贴板    w.SetClipboardText(aString)    # 关闭剪贴板    w.CloseClipboard()</code></pre><p>实现将翻译结果自动替换原文的逻辑的代码如下：</p><pre><code>while(True):        # 如果剪贴板正在被占用        try:            cs = getText()        except:            time.sleep(1)            cs = getText()        print(&apos;cs&apos;,cs)        if cs and cs != ls:            print(&apos;准备翻译&apos;)            content = getText()            tk = js.getTk(content)            res = translate(tk, content)            setText(res)            time.sleep(1)            ls = res</code></pre><p>值得注意的是，系统剪贴板对象是单例模式的，在操作系统范围内只有一个，而且读写剪贴板都是互斥的，在读（写）剪贴板的同时不允许任何对剪贴板的写（读）操作。试想这样一种情景，我们在其他软件中 Ctrl + C 写入剪贴板，而此时我们的程序代码正好执行到读剪贴板那一行，毫无疑问会报错，我的解决办法是使用 try…except 语句延时 1 s再读取，这样可以大大降低读写碰撞的概率，但无疑消耗了程序性能。最好的办法是判断剪贴板对象句柄是否被占用，其实我一直在寻找是否存在判断剪贴板对象句柄是否被占用的 API,但是一直没有找到，如果有人知道的话，欢迎评论区留言。</p><h4 id="源代码获取"><a href="#源代码获取" class="headerlink" title="源代码获取"></a>源代码获取</h4><p>关注公众号 <font size="5" color="red">月小水长</font>，后台回复，<font size="5" color="red">自动替换的翻译软件</font> 即可获取所有源代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;妈妈再也不用担心我的英语了。
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="谷歌翻译" scheme="https://inspurer.github.io/tags/%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT (Advanced Level) Practice NO.1002</title>
    <link href="https://inspurer.github.io/2019/03/23/PAT-Advanced-Level-Practice-NO-1002/"/>
    <id>https://inspurer.github.io/2019/03/23/PAT-Advanced-Level-Practice-NO-1002/</id>
    <published>2019-03-23T14:04:46.000Z</published>
    <updated>2019-03-23T14:08:33.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><h3 id="1002-A-B-for-Polynomials-（25-分"><a href="#1002-A-B-for-Polynomials-（25-分" class="headerlink" title="1002 A+B for Polynomials （25 分)"></a>1002 A+B for Polynomials （25 分)</h3><p>This time, you are supposed to find A+B where A and B are two polynomials.<a id="more"></a><br>Input Specification:</p><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p>K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ … N​K​​ a​N​K​​​​</p><p>where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤N​K​​&lt;⋯&lt;N​2​​&lt;N​1​​≤1000.<br>Output Specification:</p><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><p>3 2 1.5 1 2.9 0 3.2</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code>import java.util.*;//CreateTime: 2019/3/21 23:21//Author:     月小水长(https://github.com/inspurer)/*    类名:首字母大写，其他单词中首字母大写，其他小写    方法名:首字母小写，其他单词中首字母大写，其他小写    变量:与方法名规则同    包名:全部小写*/public class Main {    public static void main(String [] args){        Scanner sc = new Scanner(System.in);        String aLine = null;        String [] l = null;        HashMap&lt;Integer,Float&gt; [] hm = new HashMap[2];        for(int i = 0; i &lt; 2; i++){            aLine = sc.nextLine();            l = aLine.split(&quot; &quot;);            hm[i] = new HashMap&lt;Integer, Float&gt;(Integer.parseInt(l[0]));            for(int j = 1; j &lt; l.length; j += 2){                hm[i].put(Integer.parseInt(l[j]),Float.parseFloat(l[j+1]));            }        }        sc.close();        HashSet&lt;Integer&gt; setKeys = new HashSet&lt;&gt;(hm[0].keySet());        setKeys.addAll(hm[1].keySet());        ArrayList&lt;Integer&gt; sumKeys = new ArrayList&lt;&gt;(setKeys);        HashMap&lt;Integer,Float&gt; res = new HashMap&lt;Integer,Float&gt;();        // 排除掉系数为 0        for(int i = 0; i &lt; sumKeys.size(); i++){            int key = sumKeys.get(i);            float value = hm[0].getOrDefault(key,0.0f)+hm[1].getOrDefault(key,0.0f);            if(value == 0.0f)                continue;            res.put(key,value);        }        ArrayList resultKeys = new ArrayList(res.keySet());        Collections.sort(resultKeys, new Comparator&lt;Integer&gt;() {            @Override            public int compare(Integer o1, Integer o2) {                return o2 - o1;            }        });        // 如果项数为0，只把0输出就可以了        if(res.size() == 0) {            System.out.print(0);            return;        }        System.out.print(res.size());        System.out.print(&quot; &quot;);        for(int i = 0; i &lt; resultKeys.size(); i++){            int key = (int)resultKeys.get(i);            System.out.print(key);            System.out.print(&quot; &quot;);            System.out.printf(&quot;%.1f&quot;,res.get(key));            if(i == resultKeys.size() - 1)                break;            System.out.print(&quot; &quot;);        }    }}/*    格式错误，要求跟输入一样，浮点数保留一位小数，最后不能有空格    没有考虑到如果两个多项式相加，会出现系数为0的情况，此时不再记录（多虑的是demo分明有0输出了么，但是它是指数不是系数）    数据的类型，一定尽量开始就合适*/</code></pre><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://github.com/inspurer/PAT" target="_blank" rel="noopener">PAT Advanced Pratice 题解系列代码集合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h1&gt;&lt;h3 id=&quot;1002-A-B-for-Polynomials-（25-分&quot;&gt;&lt;a href=&quot;#1002-A-B-for-Polynomials-（25-分&quot; class=&quot;headerlink&quot; title=&quot;1002 A+B for Polynomials （25 分)&quot;&gt;&lt;/a&gt;1002 A+B for Polynomials （25 分)&lt;/h3&gt;&lt;p&gt;This time, you are supposed to find A+B where A and B are two polynomials.
    
    </summary>
    
      <category term="PAT" scheme="https://inspurer.github.io/categories/PAT/"/>
    
    
      <category term="PAT" scheme="https://inspurer.github.io/tags/PAT/"/>
    
      <category term="collection" scheme="https://inspurer.github.io/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>PAT (Advanced Level) Practice No.1001</title>
    <link href="https://inspurer.github.io/2019/03/22/PAT-Advanced-Level-Practice-No-1001/"/>
    <id>https://inspurer.github.io/2019/03/22/PAT-Advanced-Level-Practice-No-1001/</id>
    <published>2019-03-22T15:17:14.000Z</published>
    <updated>2019-03-22T15:35:08.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><h3 id="001-A-B-Format-（20-分"><a href="#001-A-B-Format-（20-分" class="headerlink" title="001 A+B Format （20 分)"></a>001 A+B Format （20 分)</h3><p>Calculate a+b and output the sum in standard format<a id="more"></a> – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).<br>Input Specification:</p><p>Each input file contains one test case. Each case contains a pair of integers a and b where −10​6​​≤a,b≤10​6​​. The numbers are separated by a space.<br>Output Specification:</p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><p>-1000000 9</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><p>-999,991</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><pre><code>import java.util.LinkedList;import java.util.Scanner;//CreateTime: 2019/3/21 23:21//Author:     月小水长(https://github.com/inspurer)/*    类名:首字母大写，其他单词中首字母大写，其他小写    方法名:首字母小写，其他单词中首字母大写，其他小写    变量:与方法名规则同    包名:全部小写*/public class Main {    public static void main(String [] args){        Scanner scanner = new Scanner(System.in);        int num1 = Integer.parseInt(scanner.next());        int num2 = Integer.parseInt(scanner.next());        scanner.close();        num1 += num2;        int flag = num1&gt;=0?1:0;        num1 = num1&gt;0?num1:-num1;        if(String.valueOf(num1).length()&lt;4) {            if (flag == 0) {                System.out.print(-num1);            } else {                System.out.print(num1);            }            return;        }        LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;();        do{            result.add(String.valueOf(num1%10));            num1 /= 10;            if((result.size()+1)%4==0&amp;&amp;num1&gt;0){                result.add(&quot;,&quot;);            }        }while (num1&gt;0);        if(flag==0){            result.add(&quot;-&quot;);        }        for(int i = result.size()-1;i&gt;=0;i--)            System.out.print(result.get(i));    }}</code></pre><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Scanner.nextInt() 方法只能接收正整数，如输入负整数则会忽略掉掉负号，相当于对输入取 abs() ，要想解决这个 Bug，可以通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num1 = Integer.parseInt(scanner.next());</span><br></pre></td></tr></table></figure><p>解决。</p><blockquote><p>next() 和 nextLine() 都接收字符串；<br>next() 方法一定要接收到有效字符串才可以结束输入，对输入有效字符之前遇到的空格键、Tab 键或回车键等，next() 方法会自动将其去掉，只有在输入有效字符之后，next() 方法才将其后输入的空格键、Tab 键或回车键视为分隔符或结束符；<br>nextLine() 方法的结束符只是回车键，即 nextLine() 方法返回的是回车键的所有字符。</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://github.com/inspurer/PAT" target="_blank" rel="noopener">PAT Advanced Pratice 题解系列代码集合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h1&gt;&lt;h3 id=&quot;001-A-B-Format-（20-分&quot;&gt;&lt;a href=&quot;#001-A-B-Format-（20-分&quot; class=&quot;headerlink&quot; title=&quot;001 A+B Format （20 分)&quot;&gt;&lt;/a&gt;001 A+B Format （20 分)&lt;/h3&gt;&lt;p&gt;Calculate a+b and output the sum in standard format
    
    </summary>
    
      <category term="PAT" scheme="https://inspurer.github.io/categories/PAT/"/>
    
    
      <category term="PAT" scheme="https://inspurer.github.io/tags/PAT/"/>
    
      <category term="scanner" scheme="https://inspurer.github.io/tags/scanner/"/>
    
  </entry>
  
  <entry>
    <title>利用Tensorflow构建自己的物体识别模型(一)</title>
    <link href="https://inspurer.github.io/2018/12/03/%E5%88%A9%E7%94%A8Tensorflow%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B-%E4%B8%80/"/>
    <id>https://inspurer.github.io/2018/12/03/利用Tensorflow构建自己的物体识别模型-一/</id>
    <published>2018-12-03T15:22:20.000Z</published>
    <updated>2019-04-10T10:38:51.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h2><p>windows10+python3.5+pycharm</p><h2 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h2><p>利用Tensorflow训练搭建自己的物体训练模型，万里长征第一步，先安装tensorflow。<a id="more"></a></p><p>tensorflow分为cpu版和gpu版，gpu版的运行速度是cpu的50倍，但是gpu版的坑太多，要安装许多开发套件,对windows的支持不够友好；更为致命的是,它需要Nvida的中高端显卡，我的电脑系统是windows10,显卡是入门级显卡，开始我还想挣扎一下，安装个gpu版，大概试了一个晚上，到底是没有成功，识时务者为俊杰，那就安装cpu版的吧。</p><blockquote><p>pip insatll tensorflow   </p></blockquote><p>假如没有报错，做个测试，运行以下代码</p><pre><code>import tensorflow as tf#指定一个常数张量first_blood = tf.constant(&apos;double kill&apos;)#创建一个会话，方便查看结果sess = tf.Session()print(str(sess.run(first_blood)))</code></pre><p>运行结果如下</p><pre><code>E:\python\python.exe &quot;E:/pycharm src/TF/__init__.py&quot;2018-12-01 23:33:25.181550: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2double killProcess finished with exit code 0</code></pre><p>如果出现警告:</p><p><code>Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2</code></p><p>翻译过来的大致意思是:<br><code>你的CPU支持AVX扩展，但是你安装的TensorFlow版本无法编译使用</code>   </p><p>此时需要在第一行代码前加上两行代码:</p><pre><code>import osos.environ[&apos;TF_CPP_MIN_LOG_LEVEL&apos;] = &apos;2&apos;import tensorflow as tf# 指定一个常数张量first_blood = tf.constant(&apos;double kill&apos;)# 创建一个会话，方便查看结果sess = tf.Session()print(str(sess.run(first_blood)))</code></pre><h2 id="下载Tensorflow-object-detection-API"><a href="#下载Tensorflow-object-detection-API" class="headerlink" title="下载Tensorflow object detection API"></a>下载Tensorflow object detection API</h2><p>如果有git的话，右键<code>git bash</code>,使用命令下载：</p><blockquote><p>git clone <a href="https://github.com/tensorflow/models.git" target="_blank" rel="noopener">https://github.com/tensorflow/models.git</a>  </p></blockquote><p>或者直接打开网站:</p><blockquote><p><a href="https://github.com/tensorflow/models" target="_blank" rel="noopener">https://github.com/tensorflow/models</a>   </p></blockquote><p>点击绿色按钮-&gt;downlaod zip   </p><p>下载好之后，把文件解压，注意解压路径不要包含中文，比如我的解压后的路径是:</p><blockquote><p>C:\Users\lenovo\Desktop\note\gitclone\models  </p></blockquote><p>如果下载速度很慢，可以参考:<a href="https://blog.csdn.net/ygdxt/article/details/82825013" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/82825013</a></p><h2 id="下载并配置protoc"><a href="#下载并配置protoc" class="headerlink" title="下载并配置protoc"></a>下载并配置protoc</h2><p>在<a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">https://github.com/google/protobuf/releases</a>中选择windows版本：   </p><p><img src="https://s2.ax1x.com/2019/04/10/AThq74.png" alt=""></p><p>只有win32,也就是windows32位的，64位是兼容32位的。  </p><p>下载好之后，解压，把bin目录下的<code>protoc.exe</code>复制到<code>..\models\research</code>文件夹下。</p><p>接着就是配置protoc了，在打开cmd下切换到<code>..\models\research</code>目录，</p><p>执行命令<code>protoc object_detection\protos\*.proto --python_out=.</code> </p><p>如果报以下的错(其实很大可能性会报错，无论是不是在管理员模式下）：</p><blockquote><p>object_detection\protos*.proto: No such file or directory</p></blockquote><p>则需要对指令做修改，指令<code>protoc object_detection\protos\*.proto --python_out=.</code>中的<code>*.proto</code>表示是对<code>research</code>目录下的所有后缀名为<code>proto</code>的文件做操作，那干脆我们把指令中的<code>*.proto</code>这部分改成所有后缀名为<code>proto</code>的文件，每执行一次，就会生成一个<code>.py</code>文件，由于文件太多，我已经把指令写成脚本:</p><pre><code>import ospath_url = os.path.join(os.getcwd(),r&quot;object_detection\protos&quot;)print(&quot;proto path:&quot;,path_url)for file in os.listdir(path_url):    cmd = &quot;protoc object_detection\protos\{} --python_out=.&quot;    if file.endswith(&quot;.proto&quot;):        command = cmd.format(file)        print(&quot;excuting command:&quot;,command)        os.popen(command)</code></pre><p>在<code>..\research</code>目录下新建一个文件<code>excuter.py</code>,把以上代码复制进去，保存运行，稍等一会儿就可以看到<code>..\research\object_detection\protos</code>目录下生成了许多<code>.py</code>文件，说明protoc配置成功。</p><h2 id="models环境变量配置"><a href="#models环境变量配置" class="headerlink" title="models环境变量配置"></a>models环境变量配置</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>依次打开：<code>我的电脑</code>—&gt;<code>高级系统设置</code>—&gt;<code>环境变量</code>，新建一个系统变量:</p><p><img src="https://s2.ax1x.com/2019/04/10/AThx91.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/04/10/AT4Sc6.png" alt=""></p><blockquote><p>系统变量名只要不和已有的重复，符合命令规范，没有其他要求，我这里是<code>tensorflow</code><br>系统变量名下有两个值,<code>..\research</code>和<code>..\research\slim</code>的绝对路径。</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在<code>..\research</code>下打开cmd，运行以下命令，</p><blockquote><p>python object_detection/builders/model_builder_test.py</p></blockquote><p>如果出现错误:  </p><p><img src="https://s2.ax1x.com/2019/04/10/AT4pjK.md.png" alt=""></p><p>报错原因是你的models路径太长，python无法找指定模块，<br>解决办法是在你的<code>python</code>安装路径下新建一个<code>tensorflow_model.pth</code>文件<br>(比如我的是<code>E:\python\Lib\site-packages</code>)<br>把写到环境变量里的那两个路径复制到该文件中。<br><img src="hhttps://s2.ax1x.com/2019/04/10/AT4Z9I.md.png" alt=""></p><p>再运行命令<code>python object_detection/builders/model_builder_test.py</code><br><img src="https://s2.ax1x.com/2019/04/10/AT4e3t.png" alt=""></p><p>说明配置成功</p><h2 id="利用tensorflow自带模型测试"><a href="#利用tensorflow自带模型测试" class="headerlink" title="利用tensorflow自带模型测试"></a>利用tensorflow自带模型测试</h2><p>测试的图片是在</p><blockquote><p><code>C:\Users\lenovo\Desktop\note\gitclone\models\research\object_detection\test_images</code>  </p></blockquote><p>我们看到这里有现成的两张图片，当然也可以换成自己的。</p><p>测试的脚本是</p><blockquote><p>C:\Users\lenovo\Desktop\note\gitclone\models\research\object_detection\object_detection_tutorial.ipynb  </p></blockquote><p>这是一个需要用<code>jupyter notebook</code>打开的文件，不过好像在<code>jupyter notebook</code>运行会有许多毛病<br>我已经把这个<code>ipynb</code>文件改写成<code>py</code>文件，并修复了一些未知问题，文件内容如下:</p><pre><code>import numpy as npimport osimport six.moves.urllib as urllibimport sysimport tarfileimport tensorflow as tfimport zipfilefrom distutils.version import StrictVersionfrom collections import defaultdictfrom io import StringIOfrom matplotlib import pyplot as pltfrom PIL import Image# This is needed since the notebook is stored in the object_detection folder.sys.path.append(&quot;..&quot;)from object_detection.utils import ops as utils_opsif StrictVersion(tf.__version__) &lt; StrictVersion(&apos;1.9.0&apos;):  raise ImportError(&apos;Please upgrade your TensorFlow installation to v1.9.* or later!&apos;)import numpy as npimport osimport six.moves.urllib as urllibimport sysimport tarfileimport tensorflow as tfimport zipfilefrom distutils.version import StrictVersionfrom collections import defaultdictfrom io import StringIOfrom matplotlib import pyplot as pltfrom PIL import Image# This is needed since the notebook is stored in the object_detection folder.sys.path.append(&quot;..&quot;)from object_detection.utils import ops as utils_opsif StrictVersion(tf.__version__) &lt; StrictVersion(&apos;1.9.0&apos;):  raise ImportError(&apos;Please upgrade your TensorFlow installation to v1.9.* or later!&apos;)from utils import label_map_utilfrom utils import visualization_utils as vis_util# What model to download.MODEL_NAME = &apos;ssd_mobilenet_v1_coco_2017_11_17&apos;MODEL_FILE = MODEL_NAME + &apos;.tar.gz&apos;DOWNLOAD_BASE = &apos;http://download.tensorflow.org/models/object_detection/&apos;# Path to frozen detection graph. This is the actual model that is used for the object detection.PATH_TO_FROZEN_GRAPH = MODEL_NAME + &apos;/frozen_inference_graph.pb&apos;# List of the strings that is used to add correct label for each box.PATH_TO_LABELS = os.path.join(&apos;data&apos;, &apos;mscoco_label_map.pbtxt&apos;)opener = urllib.request.URLopener()opener.retrieve(DOWNLOAD_BASE + MODEL_FILE, MODEL_FILE)tar_file = tarfile.open(MODEL_FILE)for file in tar_file.getmembers():  file_name = os.path.basename(file.name)  if &apos;frozen_inference_graph.pb&apos; in file_name:    tar_file.extract(file, os.getcwd())detection_graph = tf.Graph()with detection_graph.as_default():  od_graph_def = tf.GraphDef()  with tf.gfile.GFile(PATH_TO_FROZEN_GRAPH, &apos;rb&apos;) as fid:    serialized_graph = fid.read()    od_graph_def.ParseFromString(serialized_graph)    tf.import_graph_def(od_graph_def, name=&apos;&apos;)category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS, use_display_name=True)def load_image_into_numpy_array(image):  (im_width, im_height) = image.size  return np.array(image.getdata()).reshape(      (im_height, im_width, 3)).astype(np.uint8)# For the sake of simplicity we will use only 2 images:# image1.jpg# image2.jpg# If you want to test the code with your images, just add path to the images to the TEST_IMAGE_PATHS.PATH_TO_TEST_IMAGES_DIR = &apos;test_images&apos;TEST_IMAGE_PATHS = [ os.path.join(PATH_TO_TEST_IMAGES_DIR, &apos;image{}.jpg&apos;.format(i)) for i in range(1, 3) ]# Size, in inches, of the output images.IMAGE_SIZE = (12, 8)output_num = 1output_img_dic = r&apos;\output_images&apos;def run_inference_for_single_image(image, graph):  with graph.as_default():    with tf.Session() as sess:      # Get handles to input and output tensors      ops = tf.get_default_graph().get_operations()      all_tensor_names = {output.name for op in ops for output in op.outputs}      tensor_dict = {}      for key in [          &apos;num_detections&apos;, &apos;detection_boxes&apos;, &apos;detection_scores&apos;,          &apos;detection_classes&apos;, &apos;detection_masks&apos;      ]:        tensor_name = key + &apos;:0&apos;        if tensor_name in all_tensor_names:          tensor_dict[key] = tf.get_default_graph().get_tensor_by_name(              tensor_name)      if &apos;detection_masks&apos; in tensor_dict:        # The following processing is only for single image        detection_boxes = tf.squeeze(tensor_dict[&apos;detection_boxes&apos;], [0])        detection_masks = tf.squeeze(tensor_dict[&apos;detection_masks&apos;], [0])        # Reframe is required to translate mask from box coordinates to image coordinates and fit the image size.        real_num_detection = tf.cast(tensor_dict[&apos;num_detections&apos;][0], tf.int32)        detection_boxes = tf.slice(detection_boxes, [0, 0], [real_num_detection, -1])        detection_masks = tf.slice(detection_masks, [0, 0, 0], [real_num_detection, -1, -1])        detection_masks_reframed = utils_ops.reframe_box_masks_to_image_masks(            detection_masks, detection_boxes, image.shape[0], image.shape[1])        detection_masks_reframed = tf.cast(            tf.greater(detection_masks_reframed, 0.5), tf.uint8)        # Follow the convention by adding back the batch dimension        tensor_dict[&apos;detection_masks&apos;] = tf.expand_dims(            detection_masks_reframed, 0)      image_tensor = tf.get_default_graph().get_tensor_by_name(&apos;image_tensor:0&apos;)      # Run inference      output_dict = sess.run(tensor_dict,                             feed_dict={image_tensor: np.expand_dims(image, 0)})      # all outputs are float32 numpy arrays, so convert types as appropriate      output_dict[&apos;num_detections&apos;] = int(output_dict[&apos;num_detections&apos;][0])      output_dict[&apos;detection_classes&apos;] = output_dict[          &apos;detection_classes&apos;][0].astype(np.uint8)      output_dict[&apos;detection_boxes&apos;] = output_dict[&apos;detection_boxes&apos;][0]      output_dict[&apos;detection_scores&apos;] = output_dict[&apos;detection_scores&apos;][0]      if &apos;detection_masks&apos; in output_dict:        output_dict[&apos;detection_masks&apos;] = output_dict[&apos;detection_masks&apos;][0]  return output_dictfor image_path in TEST_IMAGE_PATHS:  image = Image.open(image_path)  # the array based representation of the image will be used later in order to prepare the  # result image with boxes and labels on it.  image_np = load_image_into_numpy_array(image)  # Expand dimensions since the model expects images to have shape: [1, None, None, 3]  image_np_expanded = np.expand_dims(image_np, axis=0)  # Actual detection.  output_dict = run_inference_for_single_image(image_np, detection_graph)  # Visualization of the results of a detection.  vis_util.visualize_boxes_and_labels_on_image_array(      image_np,      output_dict[&apos;detection_boxes&apos;],      output_dict[&apos;detection_classes&apos;],      output_dict[&apos;detection_scores&apos;],      category_index,      instance_masks=output_dict.get(&apos;detection_masks&apos;),      use_normalized_coordinates=True,      line_thickness=8)  plt.figure(figsize=IMAGE_SIZE)  print(1,image_np)  plt.imshow(image_np)  plt.show()  global output_num  global output_img_dic  if not os.path.exists(output_img_dic):      os.mkdir(output_img_dic)  output_img_path = os.path.join(output_img_dic,str(output_num)+&quot;.png&quot;)  plt.savefig(output_img_path)</code></pre><blockquote><p>运行上述代码需要安装<code>matplotlib</code>库，直接<code>pip install matplotlib</code>安装失败的可以去官网安装与python版本对应的whl文件。安装<code>matplotlib.whl</code>时需要先出pycharm。<br>同时由于需要下载模型文件，需要在网络好的情况下进行测试。否则就会报<code>HTTP ERROR</code></p></blockquote><h2 id="运行效果图"><a href="#运行效果图" class="headerlink" title="运行效果图"></a>运行效果图</h2><p><img src="https://s2.ax1x.com/2019/04/10/AT4njf.md.png" alt=""><br><img src="https://s2.ax1x.com/2019/04/10/AT4MDS.md.png" alt=""></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>以上就是本次教程的所有内容，后续还会有系列教程，原创作品，转载请联系<a href="mailto:2391527690@qq.com" target="_blank" rel="noopener">2391527690@qq.com</a><br>欢迎大家多多上机操作，指出本教程的不足之处，如有问题，可加群交流，群号码: 861016679<br>本文首发于<a href="https://www.jianshu.com/p/9c9b908a2b73" target="_blank" rel="noopener">我的简书</a>，如果您在本站上看到了google广告，请多多点击，算是对我的一个鼓励，能够赞赏那就更好了，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原料&quot;&gt;&lt;a href=&quot;#原料&quot; class=&quot;headerlink&quot; title=&quot;原料&quot;&gt;&lt;/a&gt;原料&lt;/h2&gt;&lt;p&gt;windows10+python3.5+pycharm&lt;/p&gt;
&lt;h2 id=&quot;安装tensorflow&quot;&gt;&lt;a href=&quot;#安装tensorflow&quot; class=&quot;headerlink&quot; title=&quot;安装tensorflow&quot;&gt;&lt;/a&gt;安装tensorflow&lt;/h2&gt;&lt;p&gt;利用Tensorflow训练搭建自己的物体训练模型，万里长征第一步，先安装tensorflow。
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="tensorflow" scheme="https://inspurer.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>一文搞定 Python 的时间处理</title>
    <link href="https://inspurer.github.io/2018/12/03/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9Apython%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    <id>https://inspurer.github.io/2018/12/03/一文搞定python的时间处理/</id>
    <published>2018-12-03T15:17:58.000Z</published>
    <updated>2019-04-09T01:34:21.995Z</updated>
    
    <content type="html"><![CDATA[<p>如果认真看完这篇文章你还不知道怎么处理python的时间问题，你可以来diss我<a id="more"></a></p><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><pre><code># -*- coding: utf-8 -*-# author:           inpurer(月小水长)# pc_type           lenovo# create_date:      2018/12/3# file_name:        timetest.py# description:      月小水长，热血未凉import timet0 = time.time()#description:   输出当前时间距离1970.1.1的秒数,精确到小数点后6位，也叫做时间戳#output sample: 1543799532.602318print(t0)t1 = time.localtime(t0)#description:   把时间戳转成元组,包含七个元素,前六个见名知意,tm_wday是指今天是当前周的第几天(index from 0),tm_yday类似,tm_isdst是否是夏令时,不用关心#output sample: time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=22, tm_sec=24, tm_wday=0, tm_yday=337, tm_isdst=0)print(t1)#so,可以这样输出今天是今年的第多少天print(t1[-2]+1)#下面是对该元组的格式化#description:   简单可读形式#output sample: Mon Dec  3 09:31:18 2018t2 = time.asctime(t1)print(t2)#description:   可通过参数设置成各种形式，下面是一种标准形式,各参数见名知意#output sample: 2018-12-03 09:33:36t3 = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, t1)print(t3)#%y 两位数的年份表示（00-99）# %Y 四位数的年份表示（000-9999）# %m 月份（01-12）# %d 月内中的一天（0-31）# %H 24小时制小时数（0-23）# %I 12小时制小时数（01-12）# %M 分钟数（00=59）# %S 秒（00-59）## %a 本地简化星期名称# %A 本地完整星期名称# %b 本地简化的月份名称# %B 本地完整的月份名称# %c 本地相应的日期表示和时间表示# %j 年内的一天（001-366）# %p 本地A.M.或P.M.的等价符# %U 一年中的星期数（00-53）星期天为星期的开始# %w 星期（0-6），星期天为星期的开始# %W 一年中的星期数（00-53）星期一为星期的开始# %x 本地相应的日期表示# %X 本地相应的时间表示# %Z 当前时区的名称# %% %号本身# 下面是把格式化字符串转成元组# description:      第一个参数个格式化后的字符串,后一个参数和格式化对应，便于反格式化# output sample:    time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=9, tm_min=47, tm_sec=7, tm_wday=0, tm_yday=337, tm_isdst=-1)t4 = time.strptime(t3,&apos;%Y-%m-%d %H:%M:%S&apos;)print(t4)# 把元组转成时间戳#description:   是time.localtime的反函数,不过由于格式化的原因，精度有所下降#output sample: 1543801627.0t5 = time.mktime(t4)print(t5)</code></pre><h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><pre><code># -*- coding: utf-8 -*-# author:           inpurer(月小水长)# pc_type           lenovo# create_date:      2018/12/3# file_name:        timetest.py# description:      月小水长，热血未凉import datetime#通过datetime.datetime.now()可以获得当前日期时间的一个实例#这个实例是一个datetime类对象而不是字符串#虽然直接打印该实例输出的是一个字符串,只是调用datetime实现的__str__方法而已t0 = datetime.datetime.now()print(t0)           #print: 2018-12-03 12:55:49.905971print(type(t0))     #print: &lt;class &apos;datetime.datetime&apos;&gt;#然后就可以通过对象名.的方法输出各个时间信息,该信息是一个int类型print(t0.year)          #print: 2018print(type(t0.year))    #print: &lt;class &apos;int&apos;&gt;print(t0.month)print(t0.day)print(t0.hour)print(t0.minute)print(t0.second)</code></pre><h2 id="时间的存储，比较"><a href="#时间的存储，比较" class="headerlink" title="时间的存储，比较"></a>时间的存储，比较</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>理论上我们可以通过拼接datetime.datetime.now()实例的各个时间变量来构建我们自己的想要时间,例如我们想要存储<code>year-month-day</code>这样的时间信息，我们可以这样做:</p><pre><code>import datetimet0 = datetime.datetime.now()#注意year/month/day都是int类型，不像java那样可以直接拼接字符串和数字wanted_time = str(t0.year)+&quot;-&quot;+str(t0.month)+&quot;-&quot;+str(t0.day)</code></pre><p>但是，这样做会有非常尴尬的问题:格式不统一，可能会出现下面这样的存储形式：  </p><blockquote><p>2018-1-1<br>2018-1-11<br>2018-11-1<br>2018-11-11<br>……………..  </p></blockquote><p>特别是在数据量非常庞大的时候，阅读起来非常费力，这是因为year/month/day这些都是int型，所以<code>1</code>就是<code>1</code>，不会显示成<code>01</code>,要实现对齐效果，必须还得字符串的格式化，所以，我们通常用的是time模块(其实datetime也有字符串的格式化，不过展开讲就太多了，不必要浪费这么多学习成本)</p><pre><code>import timet0 = time.localtime()wanted_time = time.strftime(&quot;%Y-%m-%d&quot;,t0)</code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>就拿上面刚刚说的<code>wanted_time</code>来说，可以直接通过<code>&gt;</code>、<code>=</code>、<code>&lt;</code>这些符号来比较，因为<code>wanted_time</code>就是一个字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果认真看完这篇文章你还不知道怎么处理python的时间问题，你可以来diss我
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="time" scheme="https://inspurer.github.io/tags/time/"/>
    
      <category term="datetime" scheme="https://inspurer.github.io/tags/datetime/"/>
    
  </entry>
  
  <entry>
    <title>Python 实现微信自动回复和群聊助手</title>
    <link href="https://inspurer.github.io/2018/12/01/Python%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%92%8C%E7%BE%A4%E8%81%8A%E5%8A%A9%E6%89%8B/"/>
    <id>https://inspurer.github.io/2018/12/01/Python实现微信自动回复和群聊助手/</id>
    <published>2018-12-01T01:45:02.000Z</published>
    <updated>2019-04-09T01:33:56.058Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于我的简书<a href="https://www.jianshu.com/p/4b7b4f4fb0e4" target="_blank" rel="noopener">https://www.jianshu.com/p/4b7b4f4fb0e4</a><a id="more"></a></p><h1 id="本教程的作用"><a href="#本教程的作用" class="headerlink" title="本教程的作用"></a>本教程的作用</h1><p>零基础手把手教你打造一款微信机器人，包括好友聊天自动回复和群聊助手两个部分，零基础！话不多说，下面开始实战编码。</p><h1 id="第一部分-好友聊天自动回复"><a href="#第一部分-好友聊天自动回复" class="headerlink" title="第一部分:好友聊天自动回复"></a>第一部分:好友聊天自动回复</h1><h2 id="第一步，安装python环境。"><a href="#第一步，安装python环境。" class="headerlink" title="第一步，安装python环境。"></a>第一步，安装python环境。</h2><p>打开python官网<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a>，下载与你的电脑系统相匹配的python发行版本，推荐python3.5-python3.6,版本太高了可能有许多未知的bug，太低了兼容性不太好。</p><h2 id="第二步，安装itchat库"><a href="#第二步，安装itchat库" class="headerlink" title="第二步，安装itchat库"></a>第二步，安装itchat库</h2><p>在命令行下输入<code>pip install itchat</code>完成安装   </p><h2 id="第三步，编写代码"><a href="#第三步，编写代码" class="headerlink" title="第三步，编写代码"></a>第三步，编写代码</h2><p>核心代码如下：</p><pre><code>  #coding=utf8import itchat# 当接收到的消息是Text，即文字消息#注册re_msg的意义在于，告诉itchat每次有符合特定条件的消息，itchat要把消息作为参数，去调用re_msg。@itchat.msg_register(&apos;Text&apos;)def text_reply(msg):    #message:取出msg里面的文本消息    message = msg[&apos;Text&apos;]    # 回复给好友    replay = u&apos;肖涛已在电脑上登陆网页微信，但暂时无法进行交流,可以给他发送电脑QQ消息哈&apos;      #主要是一些关键词设置    # if B in A 如果 A中有B的话    if u&apos;干什么&apos; in message:        replay = u&apos;在忙呢&apos;    elif u&apos;逼&apos; in message:        replay = u&apos;含有敏感词汇,请注意言辞&apos;    elif u&apos;生气&apos; in message:        replay = u&apos;生气对身体不好&apos;    elif u&apos;?&apos; in  message:        replay = u&apos;哈哈，我也不知道&apos;    elif u&apos;不理你&apos; in message:        replay = u&apos;乖，忙完给你买糖吃&apos;    elif u&apos;涛&apos; in message:        replay = u&apos;他是我主人&apos;    elif u&apos;厉害&apos; in message:        replay = u&apos;不不不，辣鸡一个&apos;    elif u&apos;你好&apos; in message:        replay = u&apos;你好哇&apos;    elif u&apos;好吧&apos; in message:        replay = u&apos;再见&apos;    return replay#弹出扫码登录界面,参数这样设置的好处是短时间内退出程序，再次登录可以不用扫码itchat.auto_login(hotReload=True)#开启自动回复itchat.run()</code></pre><p>以上代码都是本人亲自编写，如需转载请私信我。<br>代码截至2018/11/30本人调试有效，最新的代码更新在我的github：<a href="https://github.com/inspurer/PythonLearning/blob/master/python%E5%B0%8F%E9%A1%B9%E7%9B%AE/itchat_wechat/auto_replay.py" target="_blank" rel="noopener">auto_replay.py</a>如有问题欢迎评论。</p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>运行之后，会弹出一个二维码，用微信扫一扫登录网页版微信之后，这份代码就会接管你的消息通知。下面是一个简单的效果图<br><img src="https://upload-images.jianshu.io/upload_images/13236872-034194b9a0fe532b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20180331100337372.png"></p><h1 id="第二部分：群聊助手"><a href="#第二部分：群聊助手" class="headerlink" title="第二部分：群聊助手"></a>第二部分：群聊助手</h1><p>第一步是点对点的消息自动回复，本部分实现的是点对多、在群中的消息自动回复。请确认上一部分实现无误之后再来尝试第二部分，因为第二部分需要第一部分的环境配置做支撑。</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><pre><code>  import itchatimport requestsdef get_response(msg):    apiUrl = &apos;http://www.tuling123.com/openapi/api&apos;   #改成你自己的图灵机器人的api        &apos;key&apos;: &apos;ce697b3fc8b54d5f88c2fa59772cb2cf&apos;,  # Tuling Key         &apos;info&apos;: msg,  # 这是我们发出去的消息        &apos;userid&apos;: &apos;wechat-robot&apos;,  # 这里可随意修改    }    # 通过如下命令发送一个post请求    r = requests.post(apiUrl, data=data).json()    return r.get(&apos;text&apos;)@itchat.msg_register(itchat.content.TEXT)#用于接收来自朋友间的对话消息  #如果不用这个，朋友发的消息便不会自动回复 def print_content(msg):    return get_response(msg[&apos;Text&apos;])#用于接收群里面的对话消息@itchat.msg_register([itchat.content.TEXT], isGroupChat=True)def print_content(msg):    return get_response(msg[&apos;Text&apos;])itchat.auto_login(True)itchat.run()</code></pre><h2 id="接入图灵机器人"><a href="#接入图灵机器人" class="headerlink" title="接入图灵机器人"></a>接入图灵机器人</h2><p>打卡图灵机器人官网，<a href="http://www.tuling123.com/" target="_blank" rel="noopener">http://www.tuling123.com/</a>,注册账号，新建一个机器人，如下图<br><img src="https://upload-images.jianshu.io/upload_images/13236872-e6ca6877df235781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20180718175512463.png"><br>把图中的apikey替换到代码里就行，如果你要用我的，我也无法拒绝，毕竟我的apikey也贴出来了。</p><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="https://upload-images.jianshu.io/upload_images/13236872-c4c3a65b233be1cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="和上一个效果图不同的是，这是在一个群里的消息"></p><h2 id="简要原理"><a href="#简要原理" class="headerlink" title="简要原理"></a>简要原理</h2><p>一但接收到信息，就会调用get_response()方法，把消息传给图灵机器人，然后图灵机器人把回复信息再返回给微信。</p><p>截至2018/11/30代码运行无误，最新更新在我的github：<a href="https://github.com/inspurer/PythonLearning/blob/master/python%E5%B0%8F%E9%A1%B9%E7%9B%AE/itchat_wechat/grouphandler.py" target="_blank" rel="noopener">grouphandler.py</a><br>如有问题请评论，如需转载请私信我。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本篇文章参考了我的两篇csdn博客<br><a href="https://blog.csdn.net/ygdxt/article/details/79766197" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/79766197</a><br><a href="https://blog.csdn.net/ygdxt/article/details/81101020" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/81101020</a><br>在这里推荐两个python代码仓库：<br>一个是<a href="https://github.com/inspurer/PythonLearning" target="_blank" rel="noopener">PythonLearning</a>,这里面有我学习python的课程学习资料、以及一些我实战编写的代码，<br>另一个是<a href="https://github.com/inspurer/PythonSpider" target="_blank" rel="noopener">PythonSpider</a>,这里面主要是一些我写的python实现的爬虫。<br>更多的请访问我的github，欢迎star，fork.<br>另外欢迎关注微信公众号：inspurer</p><p>如果你觉得本篇文章不错，不妨打赏一下，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于我的简书&lt;a href=&quot;https://www.jianshu.com/p/4b7b4f4fb0e4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/4b7b4f4fb0e4&lt;/a&gt;
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="itchat" scheme="https://inspurer.github.io/tags/itchat/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬取学校教务系统</title>
    <link href="https://inspurer.github.io/2018/11/30/python%E7%88%AC%E5%8F%96%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://inspurer.github.io/2018/11/30/python爬取学校教务系统/</id>
    <published>2018-11-30T05:58:53.000Z</published>
    <updated>2019-04-10T09:34:49.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写这个爬虫的缘由"><a href="#写这个爬虫的缘由" class="headerlink" title="写这个爬虫的缘由"></a>写这个爬虫的缘由</h1><p>以前用java写过一个爬取学校的教务系统的爬虫 <a href="https://blog.csdn.net/ygdxt/article/details/81158321" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/81158321</a>，最近痴迷Python爬虫，了解到许多强大的库，想再一次用学校的教务系统做下测试。<br><a id="more"></a><br>这一次我首先想到的是新的教务系统，这个难度更大，因为有了验证码识别反爬，由于我是用的tessocr库识别验证码,(具体配置过程可以参考我之前的博客<a href="https://blog.csdn.net/ygdxt/article/details/83793746" target="_blank" rel="noopener">    python填坑之路:tesserocr配置</a>)<br>用Requests.get方法把验证码下载下来识别之后，同时因为我爬取网页是用的selenium做的模拟网页动作，这里就有一个同步性的问题，不能保证selenium请求网页上的验证码和requests请求的验证码是同一个，相当于selenium、requests分别请求了一次登陆网页，两个网页上的验证码显然是不同的。所以</p><pre><code>怎么保证请求登录界面得到的网页上的验证码和我们请求验证码服务器返回的验证码是同一个验证码是同一个是一个很迷人的问题，我开始还以为可以从网页源代码上直接定位到这个验证码，结果显示这个验证码在登录界面的  的存在形式不是一个..png/jpg,而是通过src=“验证码服务器”来实现异步加载</code></pre><p>同时，由于tessocr识别验证码的成功率可能只有50%，要提高验证率可能还要对接云打码，果断放弃了爬取新教务系统的想法，还是爬取原来的没有验证码的旧教务系统，<br>其实新旧教务系统最大的区别就是登陆界面不一样，登陆之后都一样，貌似用了重定向<br>ps:如果你对这个问题有什么好的解决办法，请不吝赐教</p><h1 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h1><p>详细的代码解释就看注释吧，有什么问题欢迎交流</p><h2 id="执行爬虫的主程序csu-py，里面有许多测试用的注释代码，就不删了"><a href="#执行爬虫的主程序csu-py，里面有许多测试用的注释代码，就不删了" class="headerlink" title="执行爬虫的主程序csu.py，里面有许多测试用的注释代码，就不删了"></a>执行爬虫的主程序<code>csu.py</code>，里面有许多测试用的注释代码，就不删了</h2><pre><code>from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.select import Selectfrom config import *import timebroswer = webdriver.Chrome()wait = WebDriverWait(broswer, 10)def search():    try:        broswer.get(&quot;http://csujwc.its.csu.edu.cn/jsxsd/kscj/yscjcx_list&quot;)        account = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#userAccount&quot;))        )        password = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#userPassword&quot;))        )        submit = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#btnSubmit&quot;))        )    except TimeoutException:        return search()    #登录    account.send_keys(ACCOUNT)    password.send_keys(PASSWORD)    submit.click()   #进入我的成绩界面    my_score = wait.until(        EC.presence_of_element_located((By.CSS_SELECTOR,&quot;body &gt; div.wap &gt; a:nth-child(3) &gt; div&quot;))    )    my_score.click()#成绩和平均分    # my_rank = wait.until(    #     EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child(4) &gt; a&quot;))    # )    # my_rank.click()    #    # rank = wait.until(    #     EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#dataList &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(3)&quot;))    # )    # #http://www.w3school.com.cn/cssref/selector_nth-child.asp nth-child(n)的用法    # average_score = wait.until(    #     EC.presence_of_element_located((By.CSS_SELECTOR, &quot;#dataList &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(4)&quot;))    # )    #    # print(&apos;您的平均成绩是:&apos;+average_score.text+&quot;\n排名:&quot;+rank.text)#逐次展示 我的成绩八个子项    # css_selector = &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child({0}) &gt; a&quot;    # for i in range(8):    #     # 将滚动条移动到页面的顶部    #     js = &quot;var q=document.documentElement.scrollTop=0&quot;    #     broswer.execute_script(js)    #     time.sleep(2)    #    #     aviable_score = wait.until(    #         EC.presence_of_element_located((By.CSS_SELECTOR, css_selector.format(str(i+1))))    #     )    #     aviable_score.click()    #    #    #     #将滚动条移动到页面的底部    #     for j in range(8):    #         js=&quot;var q=document.documentElement.scrollTop=&quot;+str(j*200)    #         broswer.execute_script(js)    #         time.sleep(1)    #处理select https://www.cnblogs.com/imyalost/p/7846653.html    yxcj = wait.until(        EC.element_to_be_clickable((By.CSS_SELECTOR, &quot;#LeftMenu1_divChildMenu &gt; ul &gt; li:nth-child(1) &gt; a&quot;))    )    select_score_element = broswer.find_element_by_css_selector(&quot;#xnxq01id&quot;)    select_score = Select(select_score_element)    #得到下拉列表的所有子项    select_score_items = broswer.find_elements_by_css_selector(&quot;#xnxq01id option&quot;)    select_score_items_text = []    for item in select_score_items:        select_score_items_text.append(item.text)        #print(item.text)    scores_dic = {}    for i in range(len(select_score.options)):        #不加这两行会报错，原因： https://blog.csdn.net/ulebo/article/details/52128033        print(&quot;*****************************************************&quot;+select_score_items_text[i]+              &quot;*****************************************************&quot;)        select_score_element = broswer.find_element_by_css_selector(&quot;#xnxq01id&quot;)        select_score = Select(select_score_element)        select_score.select_by_index(i)        time.sleep(1)        score_table = broswer.find_element_by_css_selector(&quot;#dataList&quot;)        data = score_table.text.replace(&quot;+&quot;,&quot;&quot;)        data = data.split(&quot;\n&quot;)        datalist = []        for line in data:            datalist.append(line.split())        scores_dic[select_score_items_text[i]] = datalist    return scores_dic[select_score_items_text[0]]def main():    search()if __name__ ==&quot;__main__&quot;:    main()</code></pre><h2 id="ui-py程序的gui，直接运行这个就好，它会调用csu-py"><a href="#ui-py程序的gui，直接运行这个就好，它会调用csu-py" class="headerlink" title="ui.py程序的gui，直接运行这个就好，它会调用csu.py"></a><code>ui.py</code>程序的gui，直接运行这个就好，它会调用<code>csu.py</code></h2><pre><code>    #coding=utf-8import wximport wx.gridimport csuclass UI(wx.Frame):    def __init__(self):        wx.Frame.__init__(self,parent=None,title=&quot;成绩查询&quot;,size=(1050,560))        grid = wx.grid.Grid(self,pos=(10,0),size=(1050,500))        grid.CreateGrid(100,9)        for i in range(100):            for j in range(9):                grid.SetCellAlignment(i,j,wx.ALIGN_CENTER,wx.ALIGN_CENTER)        grid.SetColLabelValue(0, &quot;序号&quot;) #第一列标签        grid.SetColLabelValue(1, &quot;初修学期&quot;)        grid.SetColLabelValue(2, &quot;获得学期&quot;)        grid.SetColLabelValue(3, &quot;课程&quot;)        grid.SetColLabelValue(4, &quot;成绩&quot;)  # 第一列标签        grid.SetColLabelValue(5, &quot;学分&quot;)        grid.SetColLabelValue(6, &quot;课程属性&quot;)        grid.SetColLabelValue(7, &quot;课程性质&quot;)        grid.SetColLabelValue(8, &quot;获得方式&quot;)  # 第一列标签        grid.SetColSize(0,50)        grid.SetColSize(1,100)        grid.SetColSize(2,100)        grid.SetColSize(3,350)        grid.SetColSize(4,50)        grid.SetColSize(5,50)        grid.SetColSize(6,50)        grid.SetColSize(7,100)        grid.SetColSize(8,100)        grid.SetCellTextColour(&quot;NAVY&quot;)        data = csu.search()        data.remove(data[0])        print(data)        for i,item1 in enumerate(data):            for j,item2 in enumerate(item1):                grid.SetCellValue(i,j,data[i][j])        passapp = wx.App()frame = UI()frame.Show()app.MainLoop()</code></pre><h2 id="想要运行代码，具体的配置过程请参考readme"><a href="#想要运行代码，具体的配置过程请参考readme" class="headerlink" title="想要运行代码，具体的配置过程请参考readme"></a>想要运行代码，具体的配置过程请参考<a href="https://github.com/inspurer/PythonSpider/blob/master/csu/readme.md" target="_blank" rel="noopener">readme</a></h2><h2 id="运行结果预览"><a href="#运行结果预览" class="headerlink" title="运行结果预览"></a>运行结果预览</h2><p><img src="https://s2.ax1x.com/2019/04/10/ATgMBd.png" alt=""><br>如图片不可加载，请点击<a href="https://blog.csdn.net/ygdxt/article/details/84591649" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/84591649</a></p><h1 id="源代码地址https-github-com-inspurer-PythonSpider-tree-master-csu"><a href="#源代码地址https-github-com-inspurer-PythonSpider-tree-master-csu" class="headerlink" title="源代码地址https://github.com/inspurer/PythonSpider/tree/master/csu"></a>源代码地址<a href="https://github.com/inspurer/PythonSpider/tree/master/csu" target="_blank" rel="noopener">https://github.com/inspurer/PythonSpider/tree/master/csu</a></h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写这个爬虫的缘由&quot;&gt;&lt;a href=&quot;#写这个爬虫的缘由&quot; class=&quot;headerlink&quot; title=&quot;写这个爬虫的缘由&quot;&gt;&lt;/a&gt;写这个爬虫的缘由&lt;/h1&gt;&lt;p&gt;以前用java写过一个爬取学校的教务系统的爬虫 &lt;a href=&quot;https://blog.csdn.net/ygdxt/article/details/81158321&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ygdxt/article/details/81158321&lt;/a&gt;，最近痴迷Python爬虫，了解到许多强大的库，想再一次用学校的教务系统做下测试。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬取b站视频</title>
    <link href="https://inspurer.github.io/2018/11/25/python%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/"/>
    <id>https://inspurer.github.io/2018/11/25/python爬取b站视频/</id>
    <published>2018-11-25T11:46:01.000Z</published>
    <updated>2019-04-09T01:48:50.391Z</updated>
    
    <content type="html"><![CDATA[<p>python爬虫系列：<br>上一篇<br><a href="https://inspurer.github.io/2018/11/14/python%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93/#more">python爬取图虫网图库</a><br>今天突然来了兴趣想要爬取下载b站视频，话不多说，说干就干。<a id="more"></a></p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><h1 id="下载仓库"><a href="#下载仓库" class="headerlink" title="下载仓库"></a>下载仓库</h1><pre><code>git@github.com:inspurer/PythonSpider.git </code></pre><p>或者直接下载:<a href="https://github.com/inspurer/PythonSpider/tree/master/bilibili" target="_blank" rel="noopener">https://github.com/inspurer/PythonSpider/tree/master/bilibili</a>   </p><h1 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h1><p>随便打开一个b站的界面，比如<br><img src="https://s2.ax1x.com/2019/04/09/A5Hf6P.md.png" alt="在这里插入图片描述">将url复制到代码中去，运行代码，稍等一会儿，上述图中的视频就被下载下来了。  </p><h1 id="How-to-Code"><a href="#How-to-Code" class="headerlink" title="How to Code"></a>How to Code</h1><h2 id="分析网页源码"><a href="#分析网页源码" class="headerlink" title="分析网页源码"></a>分析网页源码</h2><p>按f12浏览器开发者工具 ，通过一番审查，我们定位到视频的url在网页源代码的位置如下：   </p><pre><code>window.__playinfo__={&quot;from&quot;:&quot;local&quot;,&quot;result&quot;:&quot;suee&quot;,&quot;quality&quot;:32,&quot;format&quot;:&quot;flv480&quot;,&quot;timelength&quot;:408884,&quot;accept_format&quot;:&quot;flv720,flv480,flv360&quot;,&quot;accept_description&quot;:[&quot;高清 720P&quot;,&quot;清晰 480P&quot;,&quot;流畅 360P&quot;],&quot;accept_quality&quot;:[64,32,15],&quot;video_codecid&quot;:7,&quot;video_project&quot;:true,&quot;seek_param&quot;:&quot;start&quot;,&quot;seek_type&quot;:&quot;offset&quot;,&quot;durl&quot;:[{&quot;order&quot;:1,&quot;length&quot;:408884,&quot;size&quot;:42782550,&quot;ahead&quot;:&quot;EhA=&quot;,&quot;vhead&quot;:&quot;AWQAHv/hAB5nZAAerNlA2D3n//AoACfxAAADAAEAAAMAMA8WLZYBAAVo6+zyPA==&quot;,&quot;url&quot;:&quot;http://upos-hz-mirrorkodo.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?e=ig8euxZM2rNcNbRa7b4VhoMz7WhjhwdEto8g5X10ugNcXBlqNxHxNEVE5XREto8KqJZHUa6m5J0SqE85tZvEuENvNC8xNEVE9EKE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1543136253&amp;dynamic=1&amp;gen=playurl&amp;oi=1862807981&amp;os=kodo&amp;platform=pc&amp;rate=176800&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&amp;uipk=5&amp;uipv=5&amp;um_deadline=1543136253&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;upsig=1c05ca3838af92d2c1411cf3000e8345http://upos-hz-mirrorkodo.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?e=ig8euxZM2rNcNbRa7b4VhoMz7WhjhwdEto8g5X10ugNcXBlqNxHxNEVE5XREto8KqJZHUa6m5J0SqE85tZvEuENvNC8xNEVE9EKE9IMvXBvE2ENvNCImNEVEK9GVqJIwqa80WXIekXRE9IB5QK==&amp;deadline=1543136253&amp;dynamic=1&amp;gen=playurl&amp;oi=1862807981&amp;os=kodo&amp;platform=pc&amp;rate=176800&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&amp;uipk=5&amp;uipv=5&amp;um_deadline=1543136253&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;upsig=1c05ca3838af92d2c1411cf3000e8345&quot;,&quot;backup_url&quot;:[&quot;http://upos-hz-mirrorcos.acgvideo.com/upgcxcode/48/61/45596148/45596148-1-32.flv?um_deadline=1543136253&amp;platform=pc&amp;rate=176800&amp;oi=1862807981&amp;um_sign=c479f3fd3075b359d0a04e5eb584ac55&amp;gen=playurl&amp;os=cos&amp;trid=69ea1a81ac21448f9e2189ef479a2d6d&quot;]}]}</code></pre><p>最后的url就是我们想要的结果。<br>如果在浏览器中查找不方便的话，我们可以把通过代码把网页源码输出到本地    </p><pre><code>response = requests.get(url=&apos;https://www.bilibili.com/video/av26522634&apos;, headers= self.getHtmlHeaders)        print(response.status_code)        if response.status_code == 200:            print(response.text)</code></pre><p>为了伪装成浏览器，我们需要在reqests添加Headers<br>这个Headers需要我们去浏览器中手动获取<br>切换到NetWork标签下，再选择Headers，<br><img src="https://s2.ax1x.com/2019/04/09/A5HI0S.png" alt="如图片显示有问题请到csdn观看"></p><pre><code>self.getHtmlHeaders={     &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;,     &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,     &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;,     &apos;Accept-Language&apos;: &apos;zh-CN,zh;q = 0.9&apos; }</code></pre><p>  这里只选择了几个关键的</p><h2 id="解析得到视频地址"><a href="#解析得到视频地址" class="headerlink" title="解析得到视频地址"></a>解析得到视频地址</h2><p>根据上一步分析，我们得到了网页的源码，并在源码中定位到了视频地址，接下来，我们就用代码自动获取这个地址了</p><pre><code>#用正则、json得到视频url;用pq失败后的无奈之举pattern = r&apos;\&lt;script\&gt;window\.__playinfo__=(.*?)\&lt;/script\&gt;&apos;result = re.findall(pattern, html)[0]temp = json.loads(result)#temp[&apos;durl&apos;]是一个列表，里面有很多字典#video_url = temp[&apos;durl&apos;]for item in temp[&apos;durl&apos;]:    if &apos;url&apos; in item.keys():        video_url = item[&apos;url&apos;]</code></pre><p>顺便获取下视频的名字：</p><pre><code>#用pq解析得到视频标题doc = pq(html)video_title = doc(&apos;#viewbox_report &gt; h1 &gt; span&apos;).text()</code></pre><p>然后组合返回下：</p><pre><code>return{ &apos;title&apos;: video_title, &apos;url&apos;: video_url }</code></pre><h2 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h2><p>通过在开发者工具中搜索关键词，比如上面得到的视频url，我们可以定位到在浏览器中真正下载视频的请求在哪<br><img src="https://s2.ax1x.com/2019/04/09/A5HLpn.md.png" alt="如图片显示有问题请到csdn观看">然后把它的Headers添加到reqests中，就可以下载视频了  </p><pre><code>with open(filename, &quot;wb&quot;) as f:     f.write(requests.get(url=url, headers=self.downloadVideoHeaders, stream=True, verify=False).content)</code></pre><h1 id="愉快地观看本地视频"><a href="#愉快地观看本地视频" class="headerlink" title="愉快地观看本地视频"></a>愉快地观看本地视频</h1><p><img src="https://s2.ax1x.com/2019/04/09/A5HxmT.png" alt="如图片显示有问题请到csdn观看">如果你下载的视频在本地播放不了，请不要试图修改源代码中保存文件的格式由<code>.flv</code>改成<code>.mp4</code>,因为b站的视频本来就是flv格式的，需要用特殊的视频播放器播放，这里推荐一个无毒无害的KMPlayer,<a href="https://pan.baidu.com/s/1DBOaPGbdTXOvodbrZRhzmQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1DBOaPGbdTXOvodbrZRhzmQ</a>,提取码：fw0b </p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>工程所有源代码均已上传至github，<a href="https://github.com/inspurer/PythonSpider/tree/master/bilibili" target="_blank" rel="noopener">https://github.com/inspurer/PythonSpider/tree/master/bilibili</a><br>欢迎star,fork。<br>如图片显示有问题请到csdn观看<a href="https://blog.csdn.net/ygdxt/article/details/84501500" target="_blank" rel="noopener">https://blog.csdn.net/ygdxt/article/details/84501500</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python爬虫系列：&lt;br&gt;上一篇&lt;br&gt;&lt;a href=&quot;https://inspurer.github.io/2018/11/14/python%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93/#more&quot;&gt;python爬取图虫网图库&lt;/a&gt;&lt;br&gt;今天突然来了兴趣想要爬取下载b站视频，话不多说，说干就干。
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://inspurer.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="b站" scheme="https://inspurer.github.io/tags/b%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Python 函数参数的填坑之路</title>
    <link href="https://inspurer.github.io/2018/11/22/python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>https://inspurer.github.io/2018/11/22/python函数参数的填坑之路/</id>
    <published>2018-11-22T12:08:55.000Z</published>
    <updated>2019-04-09T01:32:46.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在看<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="noopener">廖雪峰老师的python3教程之函数的参数</a><br>受益匪浅，但是在实践的过程中，发现了一些不解之谜<a id="more"></a></p><h1 id="两个错误"><a href="#两个错误" class="headerlink" title="两个错误"></a>两个错误</h1><pre><code>import _threadimport timedef func1(x):    while x:        print(x)        x = x -1_thread.start_new_thread(function=func1,args=(5,),kwargs=None)time.sleep(6)</code></pre><p>再看python3中start_new_thread()函数的声明</p><pre><code>def start_new_thread(function, args, kwargs=None):</code></pre><p>按照我们的理论，我们开启多线程的那句代码是完全没有问题的，可是事实上它报错：  </p><pre><code>TypeError: start_new_thread() takes no keyword arguments</code></pre><p>难道我们的理论有问题？带着这个疑问，我又遇到一个问题:</p><pre><code>import threadingdef func1(x):    while x:        print(x)        x = x -1threading.Thread(func1,(5,)).start()</code></pre><p>再看python3中Thread类构造()函数的声明</p><pre><code>def __init__(self, group=None, target=None, name=None,             args=(), kwargs=None, *, daemon=None):</code></pre><p>它居然又报错？</p><pre><code>AssertionError: group argument must be None for now</code></pre><h1 id="探讨过程"><a href="#探讨过程" class="headerlink" title="探讨过程"></a>探讨过程</h1><p>（以下过程针对第二个错误，第一个错误道理类似）<br>带着疑问，我看了Thread类的构造函数</p><pre><code>def __init__(self, group=None, target=None, name=None,     args=(), kwargs=None, *, daemon=None):      &quot;&quot;&quot;This constructor should always be called with keyword arguments. Arguments are:       *group* should be None; reserved for future extension when a ThreadGroup        class is implemented.        *target* is the callable object to be invoked by the run()        method. Defaults to None, meaning nothing is called.        。。。略        assert group is None, &quot;group argument must be None for now&quot;        。。。略</code></pre><p>   我们看到，第三行说明，本函数只接受关键字实参调用，所以我们之前的代码改成</p><pre><code>import threadingdef func1(x):    while x:        print(x)        x = x -1threading.Thread(target=func1,args=(5,)).start()</code></pre><p>就能顺利开启子线程了，那么它是如何实现只能接受关键字参数的呢？<br>我们看到Thread类的构造函数定义中有一句这样的断言</p><pre><code>assert group is None, &quot;group argument must be None for now&quot;</code></pre><p>意思是，如果参数group为空,通过；如果非空，报错，并给出reason<code>group argument must be None for now</code>,如果我们按照之前的位置参数调用的话，由于group是第一个参数，一下在就被赋值，非空，抛出异常，这符合我们之前的实践。同时，我在网上搜集了许多资料，诸如<code>修饰器</code>之类的也能使函数只接受关键字参数 。</p><p>错误一探讨过程道理类似，在此不再赘述。</p><h1 id="验证及结论"><a href="#验证及结论" class="headerlink" title="验证及结论"></a>验证及结论</h1><p>编码</p><pre><code>class MyThread:    def __init__(self, group=None, target=None, name=None,    args=(), kwargs=None, *, daemon=None):        print(&apos;Thread sucess&apos;)    def start_new_thread(function, args, kwargs=None):    print(&apos;_thread sucess&apos;)MyThread()MyThread.start_new_thread(args=2,kwargs=3,function=1)</code></pre><p>输出如下：</p><pre><code>Thread sucess_thread sucess</code></pre><p>显而易见，我们之前所学的理论是正确的，只不过在具体的编码中，我们通过编码<code>修改</code><br>理论，使之看上去似乎和之前的理论相矛盾，千万不要被蒙蔽了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在看&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰老师的python3教程之函数的参数&lt;/a&gt;&lt;br&gt;受益匪浅，但是在实践的过程中，发现了一些不解之谜
    
    </summary>
    
      <category term="Python" scheme="https://inspurer.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://inspurer.github.io/tags/Python/"/>
    
      <category term="函数参数" scheme="https://inspurer.github.io/tags/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>罗素:我为什么而活</title>
    <link href="https://inspurer.github.io/2018/11/15/%E7%BD%97%E7%B4%A0-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E6%B4%BB/"/>
    <id>https://inspurer.github.io/2018/11/15/罗素-我为什么而活/</id>
    <published>2018-11-15T05:44:21.000Z</published>
    <updated>2019-04-10T12:06:35.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中文译文"><a href="#中文译文" class="headerlink" title="中文译文"></a>中文译文</h1><p>对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，<a id="more"></a>这三种纯洁而无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。</p><p>我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈以致我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情可以解除孤寂一—那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣徒和诗人们所想像的天堂景象的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。</p><p>我以同样的热情寻求知识，我渴望了解人的心灵。我渴望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。</p><p>爱情和知识，尽其可能地把我引上天堂，但是同情心总把我带回尘世。痛苦的呼唤经常在我心中回荡，饥饿的儿童，被压迫被折磨者，被儿女视为负担的无助的老人以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。</p><p>这就是我的一生，我觉得值得为它活着。如果有机会的话，我还乐意再活一次。</p><h1 id="英文原文"><a href="#英文原文" class="headerlink" title="英文原文"></a>英文原文</h1><font size="4" color="#ff0000">《What I Have Lived For》  by Bertrand Russell</font><p>Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. These passions, like great winds, have blown me hither and thither, in a wayward course, over a great ocean of anguish, reaching to the very verge of despair.</p><p>I have sought love, first, because it brings ecstasy - ecstasy so great that I would often have sacrificed all the rest of life for a few hours of this joy. I have sought it, next, because it relieves loneliness–that terrible loneliness in which one shivering consciousness looks over the rim of the world into the cold unfathomable lifeless abyss. I have sought it finally, because in the union of love I have seen, in a mystic miniature, the prefiguring vision of the heaven that saints and poets have imagined. This is what I sought, and though it might seem too good for human life, this is what–at last–I have found.</p><p>With equal passion I have sought knowledge. I have wished to understand the hearts of men. I have wished to know why the stars shine. And I have tried to apprehend the Pythagorean power by which number holds sway above the flux. A little of this, but not much, I have achieved.</p><p>Love and knowledge, so far as they were possible, led upward toward the heavens. But always pity brought me back to earth. Echoes of cries of pain reverberate in my heart. Children in famine, victims tortured by oppressors, helpless old people a burden to their sons, and the whole world of loneliness, poverty, and pain make a mockery of what human life should be. I long to alleviate this evil, but I cannot, and I too suffer.</p><p>This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;中文译文&quot;&gt;&lt;a href=&quot;#中文译文&quot; class=&quot;headerlink&quot; title=&quot;中文译文&quot;&gt;&lt;/a&gt;中文译文&lt;/h1&gt;&lt;p&gt;对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="鸡汤" scheme="https://inspurer.github.io/tags/%E9%B8%A1%E6%B1%A4/"/>
    
  </entry>
  
  <entry>
    <title>李开复:追随我心</title>
    <link href="https://inspurer.github.io/2018/11/14/%E6%9D%8E%E5%BC%80%E5%A4%8D-%E8%BF%BD%E9%9A%8F%E6%88%91%E5%BF%83/"/>
    <id>https://inspurer.github.io/2018/11/14/李开复-追随我心/</id>
    <published>2018-11-14T15:22:07.000Z</published>
    <updated>2019-04-10T12:06:56.807Z</updated>
    
    <content type="html"><![CDATA[<p>并不很久的以前,也就在1979年到1980年间,在哥伦比亚大学,两个政治科学系大一的新生,在课堂上总是没精打采。其中一个是来自台湾的华裔,喜欢窝在教室左后方的一隅,听得无趣,索性呼呼大睡。这个男孩叫<a id="more"></a>李开复,此君并非厌学,而是对政治科学越来越不感兴趣。蹉跎到大二下学期,他终于决定快刀斩乱麻——转系,改学自己感兴趣的计算机。</p><p>兴趣是什么?兴趣就意味着天赋。李开复在计算机系如鱼得水,左右逢源,两年后毕业,成绩居全系之首。这样的学生用不着按部就班。在教授的推荐下,李开复进入在计算机领域独领风骚的卡内基•梅隆大学,直接攻读博士。计算机学院的院长找他谈话,劈头就问:“读博士的目的是什么?”李开复大声答:“我从大学带走的将是一篇改变世界的、顶尖的博士论文。”院长予以纠正,说:“你从这儿带走的最有价值的东西,不是一篇论文,而是你分析、思考的能力,研究、发现真理的经验,以及科学家的胸怀。这样,当你有一天改变研究方向,依然可以在任何一个新的领域出类拔萃。”李开复选定语音识别为攻读方向,经过一年“热恋”,他发现专家系统其冷如冰,远不如统计学有情有义。李开复决心“移情别恋”。他担心导师发怒,谁知得到的回答竟是:“开复,你对专家系统和统计的观点,我是不赞同的,但我可以支持你用统计的方法去做,因为我相信科学没有绝对的对错,我们都是平等的。而且,我更相信一个富有激情的人可以找到更好的解决方案。”李开复从导师的大度悟到科学的真谛,他全力以赴,放手一搏。3年过去了,李开复的研究成果及博士论文,引发了那年语音世界最大的冲击波。26岁的李开复功成名就,成为卡内基•梅隆大学最年轻的副教授。天之骄子,有尊严,有地位,有课题,有经费,出任大公司顾问,飞赴各地讲学,包括去他的祖籍之邦、魂之所系的祖国大陆。</p><p>“让世界因你而不同!”这是李开复埋在心底多年的梦想。1990年,苹果公司的一个邀请电话让李开复开始审视自己:“开复,你是想一辈子写一堆像废纸一样的学术论文,还是想真正地改变世界?”面对苹果公司的召唤,李开复旋即做出回应,走出象牙塔,加盟“改变世界”的大军。在苹果公司,李开复感受到了从纸上谈兵转入实战的无穷乐趣。1995年,33岁的李开复出任苹果公司的副总裁。</p><p>但是他仍然不满足,依然要跳槽,因为硅谷的另一家公司SGI发出了更有诱惑力的邀请——“你想做什么,然后我们根据你的兴趣对公司进行改组。”不是他们缺什么人才,让你去填补,而是诚恳地询问你需要什么平台,以便为你量身搭建。这样的机遇,李开复岂能错过!双方一拍即合, 1996年7月,李开复跳槽去了SGI。李开复奉行“自己设计自己”的人生信条,怎奈SGI是一家硬件公司,开复的长处却在软件开发,这就等于在篮球场上跑马,任是赤兔、骅骝,也撒不开四蹄。日复一日,李开复萌生去意。对于下一个选择,他立下两条标准:一是做软件,二是去中国。</p><p>机会来了。其实机会无处不在,就看你有没有做好准备。彼时,比尔•盖茨创立的微软王国要把触角伸向中国,李开复成为它的不二人选。时间:1998年金秋;职务:微软中国研究院院长。李开复在中国市场的开拓,值得写部书来描述,那是一种完全不同的创新理念、绝对领先的科学技术在神州大地生根发芽。微软只是起用了一个人,就开拓了中国市场;李开复只是“追随我心”,就一跃成为微软王国的副总裁。在你我想来,这该是李开复的最后一站。在微软占据高位,与比尔•盖茨亲密共事,坐拥财富和风光,“花迎喜气皆知笑,鸟识欢心亦解歌”。人生至此,夫复何求?李开复不这么想,他后来回忆:“我如同一部庞大机器上的零件,在中规中矩、没有任何发挥空间的环境下运行着。这是一个随时随地都可以被替换的光鲜零件。那种价值的缺失感以及精神上的落寞占据了我的内心。”微软既然已无成长空间,那就走吧!到哪儿去?他相中了Google。但他清醒地意识到,管理更多的人马,不是自己的所爱,他渴望从无到有的创新,而不是经营一个巨无霸。于是,在2009年9月,李开复又一次选择潇洒地离去。向总部递交辞呈之际,Google高管艾伦•尤斯塔斯试图用更优厚的条件予以挽留。李开复真诚地说:“我的人生还有一个缺憾没有实现,现在得去弥补。我可能创办一家‘创新工场’,和中国青年一起创造新的技术奇迹。”</p><p>如今,李开复正在按照他本人的意愿,在神州大地进行“创新工场”试验。他会成功吗?我想这是毫无疑问的,也是次要又次要的,那么,最主要的一点是什么呢?诚如他自己所言:“人生在世时间非常短,如果你总是不敢做想做的事情,那么一生过去了,你留下来的只有悔恨,只有懊恼。”“我步入丛林,因为我希望生活得有意义,我希望活得深刻,并汲取生命中所有的精华,然后从中学习,以免让我在生命终结时,才发现自己从来没有活过。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并不很久的以前,也就在1979年到1980年间,在哥伦比亚大学,两个政治科学系大一的新生,在课堂上总是没精打采。其中一个是来自台湾的华裔,喜欢窝在教室左后方的一隅,听得无趣,索性呼呼大睡。这个男孩叫
    
    </summary>
    
      <category term="励志" scheme="https://inspurer.github.io/categories/%E5%8A%B1%E5%BF%97/"/>
    
    
      <category term="励志" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97/"/>
    
      <category term="励志故事" scheme="https://inspurer.github.io/tags/%E5%8A%B1%E5%BF%97%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
</feed>
